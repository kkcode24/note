<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="author" content="kkcode">
	<title>综合笔记</title>
	<style>
	    body{margin:0;padding: 0;}
		p{
			text-align: center;
			font: normal bold 30px/2 Verdana, Arial, '宋体';
		}
		#container{
			margin:0 auto; 
			background-color: #ccc;
			color:#458B00;
			font-size: 25px;
			padding: 20px;
			position: relative;
		}
		#container div{
			width:800px;
			padding-left: 50px;
			margin-bottom: 20px;
			margin: 0 auto;
		}
		a{
			color:blue;
			text-decoration: none;
		}
		span{
			border-radius: 10px;
			padding: 10px;
			color:black;
			background-color: #F8B1BF;
		}
	</style>
</head>
<body>
<div id="container">
<div>
<pre>
<p>HTML的发展史</p>
H5的发展史

什么是H5?
狭义上，HTML的第五个版本
实际上是HTML+css+js+api的组合

HTML：Hyper Text Markup Language
解释为超文本标记语言，作用是用来做网页。

HTML 的发展史：请看
</pre>
<a href='http://dwz.cn/4CBZM7'>HTML百度百科</a>
<pre>

<p>HTML的基础标签1</p>
HTML文档是由多个元素组成
元素:组成HTML文档的基本单位,元素由&lt;&gt;和元素名组成.
元素分为两种: 
1.双标签元素:开始标签 + 内容 + 结束标签  
2.单标签元素: 只有开始标签
标签内:元素的开始标签的尖括号的元素名的后面
标签里:双标签的内容区域.
每个标签都可以单独设置其自身的属性,属性的设置写在标签内.

DOCTYPE 文档类型声明
head是双标签,只写跟文档配置有关的代码,在head里写的东西不会展示在浏览器中.

meta 单标签 源信息:
通过meta标签我们能够设置:
1.字符集的编码格式,系统默认是拉丁文的编码格式,
但是我们在使用的时候编码格式使用的是万国码UTF-8,
如果只想显示中文,可以使用gb2312或者GBK
2.还可以设置当前文档的作者信息
3.当前网页的关键字keyword

文档的内容部分,所有想在网页上显示的内容都需要写在body里
<p>HTML的基础标签2</p>
标签根据自身的属性特征可以分为两种:
1.块标签:h1-h6,p,hr,br,ul,ol,li,dl,dt,dd,pre,div
特点:
a.独占一行,就算设置宽高,也是独占一行.
b.可以设置宽高,如果不设置,默认的宽为整个浏览器的宽度,高度为其内部的内容高度.
c.支持上下的margin和padding属性
2.行标签:img,a,span,code,strong,em,sub,sup,span
行标签a在html5中可以包块元素(div),但是文档声明时必须是html5
特点:
a.不独占一行,多个标签可以在一行显示
b.不支持宽高设置,其宽高由内容撑出
c.不支持上下的margin和padding属性
标签根据标签的语义也可以分为两种:
1.有意义标签 
2.无意义标签 div span


标题标签 双标签 h1-h6 独占一行
h1标签在一个文档里只允许出现一次.
标题标签一般用在文章的标题部分,字体效果:字体会加粗,字体大小不一
h1=32px;
h2=24px;
h3=18.72px;
h4=16px;系统默认大小
h5=13.28px;
h6=12px;

分割线单标签 hr
换行符单标签 br
段落标签 双标签p 独占一行
加粗效果标签 双标签 strong
斜体双标签 em
上标双标签 sup 
下标双标签 sub

代码区域双标签 code 
用来显示计算机源码或者其他机器可以阅读的内容
写在code标签里的内容会以打印体的形式展现
缺点:不会按照代码原有的格式输出

预处理双标签 pre 
特点:会原样保留内容中的空格和换行,但是依然不识别尖括号.

img单标签 
src:填写当前需要展示的图片所在的位置,可以加载网络图片或者本地图片
alt:当图片不能加载时,显示alt 内容对图片进行说明.
加载网络图片
加载本地图片 
	绝对路径:从电脑的根目录一直找到图片的位置停止
	相对位置:从当前文档所在的文件夹位置一直找到图片的位置停止.
绝对路径 -->
	 &lt;img src="/Users/lanouhn/Desktop/1.jpg" alt="绝对路径"&gt;
相对路径
所需图片若与文档同一层则写图片名
所需图片在文档的下级使用"/"逐层查找
所需图片在文档的上级使用"../"逐层上找
下级 
&lt;img src="img/button1.png" alt="next"&gt;
上级
&lt;img src="../../1.jpg" alt="pre"&gt;


超链接双标签 a 
href:将要跳转到的网络位置或本地位置
网络位置
本地位置
锚链接
点击下载文件
点击链接在新窗口打开
空链接
&lt;a href="###"&gt;不标准空链接写法&lt;/a&gt;
&lt;a href="javascript:void(0)"&gt;标准空连接写法&lt;/a&gt;


无序列表 ul li 
有序列表 ol li
自定义列表 dl dt dd
dt:自定义标题
dd:对于标题的详细描述
dt会顶格显示,dd首行缩进

div无意义双标签 用来对整个网页的结构进行划分
span无意义双标签 用来对整个网页的结构进行划分


!!!!!!注意!!!!!
块标签可以嵌套行标签与块标签!
但是行标签只能嵌套行标签,不能嵌套块标签.

二、HTML 标签的嵌套规则
1. 块元素可以包含内联元素或某些块元素，
但内联元素却不能包含块元素，它只能包含其它的内联元素：

　　&lt;div&gt;&lt;h1&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; —— 对
　　&lt;a href=”#”&gt;&lt;span&gt;&lt;/span&gt;&lt;/a&gt; —— 对
　　&lt;span&gt;&lt;div&gt;&lt;/div&gt;&lt;/span&gt; —— 错

2. 块级元素不能放在&lt;p&gt;里面：段落里不能再分块了.
　　&lt;p&gt;&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/p&gt; —— 错
　　&lt;p&gt;&lt;div&gt;&lt;/div&gt;&lt;/p&gt; —— 错
3. 有几个特殊的块级元素只能包含内嵌元素，不能再包含块级元素，
这几个特殊的标签是：
　　h1、h2、h3、h4、h5、h6、p、dt 

<p>SEO优化</p>
优化SEO:search engine optimization 搜索引擎优化
目的:让搜索引擎尽可能快的搜索到我们的网页.

title:便于用户了解整个网页的内容,而且这也是搜索引擎
判定该网页内容的主要依据.一般内容不超过80字,尽可能的
突出该网站的关键,类型,品牌,目的等

keywords:为搜索引擎提供关键词列表,一般不超过100字.keywords属于meta标签.

description:描述:可以理解为对keywords的补充说明,一般不超过200字.

img的alt属性:搜索引擎在搜索图片是会根据alt来抓取图片.

关键词密度:一般网页中的关键词占到整篇内容的2%-8%

网页的内容要时常更新:一般在早上九点左右,百度搜索引擎
抓取更新内容中的关键词一般在早上九点左右

网页内容尽可能原创

结合当前的语义使用对应的标签. article,标题h1-h3,address,有意义的标签. 


SEM:search engine marking 搜索引擎营销
通过花钱引流
<p>表格table</p>
table表格标签 双标签 表示表格的范围
表格一般由三部分双标签组成:
1.thead
2.tbody
3.tfoot
当我们不写tbody标签时,系统会自动为我们添加一个tbody.
如果不写thead和tfoot,系统不会自动添加,
tbody标签是必须的,thead和tfoot在我们需要时再写即可.	

tr表示行,td表示单元格,
cellspacing:设置单元格之间的距离
cellpadding:设置单元格内容到单元格边界的距离
一般在thead和tfoot里的单元格用th;tbody里的单元格用td
th就是文字以加粗形式显示的

合并单元格Mergecell:
横向合并 colspan
纵向合并 rowspan
<p>form表单</p>
form表示表单的范围,其内部可以添加对应的控件
表单里一般写两个属性:
1.action:服务器地址
2.method:以post/get方式把用户填写的数据提交到服务器
a.get:不太安全,参数名与参数值可以看到
b.post:相对较为安全,参数名与参数值都不可见
如果不写method参数,默认的方式就是get

文本框 text
type表示控件的类型
name:将来要传到服务器的参数名
密码输入框 password
提交按钮 如果想要修改按钮上的文字,可以使用value属性
重置按钮 reset 会把同一表单内的所有信息还原,慎用!!
单选框 radio 
name的值相同,表示同一组,同时又是参数名
value:作为上传到服务器的参数值.
多选框 checkbox
文件选择器 file
文本域 textarea 
name:参数名
id:唯一标识
cols,rows:文本域的大小
让textarea不可拖拽的css样式:resize:none;
下拉框 select标签 option
<p>css样式</p>
CSS Cascading style sheets 层叠样式表 
作用:决定如何显示HTML元素. 
W3C的理念:结构,行为,相分离
css是HTML4.0之后出现的,版本一共有1.0 2.0 3.0

如何使用CSS:
	CSS一共有三种使用方式:
	1.内联(嵌)式:在HTML的head标签里用style标签去书写css样式
	2.内部式:在标签的内部用style属性去写css样式
	3.外联式:单独创建一个css文件去写css样式.
<p>内联式引入css</p>
内联式引入css
缺点:不具有针对性;
优点:符合W3C标准,代码清爽整洁.

当开发的网站只有一个网页时,建议使用该方式.

如果使用内联方式需要选择器的帮助来找到想要设置属性的元素.
<p>css内部引入样式</p>
缺点:
1.违背了W3C 结构 样式 行为 相分离的理念
2.不利于代码的阅读

优点:具有针对性.(很少使用)
<p>外联式引入css</p>
外联式引入的两种方式:
1.link标签引入   推荐使用
2.@import引入   有局限性

@import方式引入,需要写在style标签里
link与import的区别
1.link是html语法,而import是css语法
2.link是在html文档加载时同时开始加载对应的css文件(并发),
而import是在html文档加载完毕之后才开始加载外接css文件的.
3.link可以外接任意类型的文件,import只能外接内容为css类型的文件.
4.link方式引入的css样式我们在以后可以通过js的方式
进行修改,import方式不支持js操作.

以后用link.

当网站有多个html文档时建议使用外联式.
<p>css选择器</p>
选择器:选择html文档中的某个元素或者某些元素
选择器的语法结构:
选择器名{属性名:属性值;...}
选择器是css代码,必须写在css文件或者style标签里

1.元素选择器:会选择html文档中所有对应的元素;
但是不灵活,无法给相同类型的元素设置不同的属性值.
2.群组选择器
会获取到每个逗号之间的所有对应的元素.
3.id选择器
* 获取到对应的id值的元素
* 前提:需要给对应的元素设置id值;
* ps:id值不能重复.
4.class选择器
* 获取到对应的class值的元素
* 前提:需要给对应的元素设置class值;
* ps:class值可以重复.
* 如果一个元素需要多个class,则class名之间用空格隔开.
5.后代选择器
* 语法:   
* E F {}
* 找到E对应的元素里面所有的F对应的元素(E,F可以是元素名,id名,class名)
6.子选择器
*  语法:
*  E>F{}
* 作用:找到E对应的元素里面所有的F对应的子子子元素
* (E,F可以是元素名,id名,class名)
7.相邻兄弟选择器
* 写法:
* E+F {}
* 特点:相邻兄弟选择器所找到的一定是同级元素(E,F一定是同级元素);
* 找到与E对应的所有的元素的同级的紧挨着的下一个F对应的元素.
* (E,F可以是元素名,id名,class名)
<p>属性选择器</p>
属性选择器A
element[attribute]{}
给带有attribute属性的element标签设置的css样式.
属性选择器B
e[attr="value"]{}
给带有attr属性并且值为value的e元素设置css样式.
属性选择器C
e[attr~=value]
会选择所有的属性名为attr且值里面有value单词的e标签.
属性选择器D
e[attr*=value]
会选择所有属性名为attr且值里有value连贯字符的e标签.
<p>伪类选择器</p>
E:link
匹配到定义了超链接但没有点击过的元素.
E:visited
匹配定义了超链接且已经点击过的元素.
E:hover
鼠标停留在E元素上时.
E:active
鼠标在E元素上按下时
爱恨原则:  LoVe HAte

W3C规定了伪类选择器的顺序
1.link和visited必须放在hover之前
2.active必须放在hover之后
<p>轮廓设置</p>
outline(轮廓):绘制在元素周围的一条线,位于元素边框的外围,用于突出元素.
轮廓线不计算在盒模型尺寸内.

/*如果要给多个元素都设置轮廓,
 * 一定要将轮廓考虑到元素的尺寸里,
 * 不然会出现重叠
 */

1.outline:不兼容ie低版本
2.outline的设置跟border语法一样,
最大区别:outline不占用元素的空间大小.

轮廓线的颜色outline-color
轮廓线宽度 =>轮廓线没有高度
轮廓线样式:dotted,dashed,solid,
后面的不常用
double(双线),groove(凹槽线),ridge(凸槽线),inset(凹边),outset:凸边
<p>隐藏方式</p>
隐藏一个元素有两种方式:
1.display:none;(移除)不仅隐藏元素,而且其元素所占位置腾出来
2.visibility:hidden;(隐身)隐藏元素但其元素所占位置保留
<p>背景</p>
1.背景色
2.背景图片
3.背景图片的平铺方式
no-repeat 不平铺
repeat-x  水平平铺
repeat-y  竖直平铺
4.背景图片是否跟随屏幕滚动background-attachment
fixed:固定;
scroll:滚动;
5.背景图位置
需要填写两个值:x轴位置,y轴位置,
如果一个样式里需要填写多个值,值与值之间用空格隔开.
1.用单词表示位置
x轴:left,center,right
y轴:top,center,bottom
background-position: center bottom;
2.用具体的数值
3.使用百分比
实际上还是在使用具体的数值,计算公式如下:
x:(容器的宽度-元素的宽度)* 百分比值
y:(容器的高度-元素的高度)* 百分比值
背景设置的简写方式
1.颜色
2.图片路径
3.是否平铺
4.是否跟随滚动
5.图片位置
例子:
background: #000 url(1.jpg) no-repeat fixed center center;
在书写复合属性时,如果一个属性的值有多个,
那么这多个属性值必须相连,不可分开(像background-position)
<p>文本</p>
1.文字颜色
默认文字颜色是黑色
颜色值得三种写法:
1.用颜色对应的英文单词
2.rgba(red,green,blue,alpha);
rgb三原色,所有的颜色都由这三种颜色调和而成,三种颜色的取值范围是0~255
3.十六进制:#后面跟6个值,值的取值范围0-9,A-F

2.文字的排版方向
ltr:left to right;
rtl:right to left(先把右边填满,不影响文字的
阅读顺序的方向,但是会影响标点符号);

3.字母间距
默认值normal=0px;可以取负值
letter-spacing: 3px;
单词间距
都用于英文文本,可以给负值
word-spacing: 10px;

4.对齐方式:该属性只对行元素或者行级块元素有作用,对块级元素无效
text-align:值在下面;(一般对图片和文字居中)
left,center,right,
justify(分布对齐,不推荐使用,部分浏览器不支持该属性)
单纯的文字是匿名的行元素

5.文字修饰
text-decoration:
underline下划线/overline上划线
line-through删除线/none没有线.

6.首行缩进text-indent
1.数值类型:像素大小;(不推荐使用)
2.em单位类型:一个单位的em表示当前元素的font-size值

7.文字转化,一般用在英文文本
text-transform:值;
uppercase:转成大写;
lowercase:转成小写;
capitalize:首字母大写;

8.空白区域处理
white-space:值在下面;
normal;
nowrap 不换行;
pre 保留文本原有的格式,包括所有的空格;

9.行高line-height,x基线与x基线之间的距离
normal 默认的行高,
具体的数值.

10.文本溢出时的处理方式
text-overflow
clip:剪裁掉;
ellipsis:用省略号代替;
string:用给定的字符代替(不建议使用,有些浏览器不支持);

11.不换行,下面三个属性加在一起可以做成省略号的小效果	
white-space: nowrap;
/*文本如果溢出怎么处理*/
text-overflow: ellipsis;
/*如何处理溢出的部分*/
overflow:hidden;
<p>字体</p>
1.文字大小font-size
2.字体类型font-family
1.可以把字体类型里书写的若干个值看作一个"回退"系统来理解,
如果写了多个值,系统会从第一个一个一个判定当前的浏览器是否支持该种字体,
如果不支持,尝试下一个,
但是最后一个值必须写css通用的字体类组名,
css一共有5个通用的类族:
"serif","sans-serif",
"cursive","fantasy","monospace"

3.font-variant: small-caps;
小写字母以大写字母的形式+小写字母的高度进行显示
4.字体样式-font-style
normal 正常
oblique 强制文字斜体
italic 文字自身的斜体,如果设置的文字或者字体集内没有斜体,无效果.
5.字体粗细
1.对应的单词
normal,lighter,bold,bolder
2.具体的数值(100到900)
400=normal
700=bold

font复合属性,
书写顺序(font-size,font-family不可缺少):
* font-style,font-variant,font-weight,
font-size,line-height,font-family.
<p>盒模型</p>
HTML文档是由一个个的html元素组成的盒模型:把每一个html元素看成一个盒子
1.盒模型的结构
2.盒模型如何影响元素之间的关系
盒模型的结构
1.content(内容):用来展示文字和图片
2.padding(内边距):内容与边框的距离
3.border(边框):元素的边框 
4.margin(外边距):元素与元素之间的距离(父子元素,兄弟元素)
盒模型的两种形式
1.普通盒模型
2.怪异盒模型:box-sizing:border-box;
/*设置元素的盒模型类型
* content-box 标准盒模型
* border-box 怪异盒模型
*/

怪异盒模型:
在怪异盒模型下
盒子的宽 = width(左右padding+左右border+content)+左右margin
盒子的高 = height(上下padding+上下border+content)+上下margin

如果设置了元素的盒模型类型为怪异盒模型,此时一定要注意,我们在设置
的width,height会被之后设置的padding,border分享,
会缩小content的空间.

在普通盒模型下:
盒子的宽度 = 左右magrin+左右padding+左右border+width
盒子的高度 = 上下margin+上下padding+上下border+height
content:内容,我们平时给元素添加的内容(文字,图片,某些元素)
都会显示在content所在的区域内
padding内边距:背景色会渲染pading区域
padding简写
1.四个值 顺时针  上 右 下 左的顺序!
2.三个值 上 左右 下的顺序!
3.两个值 上下 左右顺序!
4.一个值 上下左右都为这一个值!
border
设置一个元素的边框,需要设置三个值:
1.边框宽度
2.边框类型:silid,dotted,dashed
3.边框颜色(默认黑色)
margin类似于padding,但是背景色不会渲染margin区域.


***块级元素的宽如果没有设置,其宽是从父级继承的宽度
系统会为某些元素设置默认的margin值或者padding值,
这对于我们以后尺寸的计算有影响,所以在以后的开发过程中,
首先清除掉所有元素的margin和padding值.
css首行代码:*{margin:0;padding:0}***

margin的坑点:
1.相邻兄弟元素在垂直方向上的margin值会出现融合的情况.融合后会
取两个元素里较大的值作为融合后的值.
如何解决该问题:display:inline-block;
2.当父级子级元素都设置了margin时,子级的margin值会传递到父级.
margin传递解决办法:
1.给父级加一个边框
2.给父级使用overflow:hidden属性,(推荐使用)
3.给父级或子级或两者都加display:inline-block解决;
<p>auto</p>
auto值可以帮我们灵活的进行元素的布局
在盒模型中,只有width,margin可以使用auto作为其的值.
1.水平方向上,如果width,margin-left,margin-right三个值中某个值为auto
其余值必须为定值,auto=父元素宽度-剩余两个值
2.当三个值都为定值时,系统会强制丢弃margin-right的值
3.当margin-left和margin-right的值都为auto时,width必须给定值.
<p>浮动</p>
浮动的概念
1.使用场景:用于页面布局,特别是块与块之间复杂的横向布局
2.使用inline-block布局有什么弊端:
a.改变元素原有的特性
b.低版本ie不支持inline-block属性.

文档流:是文档中显示对象所处的位置
(我们在设计网页时,按照的是从左到右,从上到下的元素布局顺序)

浮动的特点:
1.浮动只有左右浮动(left,right)
2.设置了浮动的元素,该元素的大小默认有内容撑出.
3.设置了浮动的元素可以设置宽高.(针对行元素)
4.浮动的元素,水平浮动,在父级的content的区域显示或者遇到另外一个浮动的元素
(浮动元素所处的位置由上一个元素决定,如果上一个元素是左浮动,
那就看上一个元素的右侧有没有足够的位置放下该元素,
放得下,就在上一个元素的右侧显示,
放不下,另起一行显示;

同理,如果上一个元素是右浮动,
看上一个元素的左侧有没有足够的位置放下该元素,
放得下,就在上一个元素的左侧显示,
放不下,另起一行显示.)
5.浮动的元素脱离文档流,会影响后面的元素(后一个元素会被前一个浮动的元素所覆盖,
但其上有文字,图片,不会被覆盖,使用该特性,可以做文字环绕效果)
6.块级元素设置了浮动之后自动(auto)margin失效.
<p>浮动造成的影响01</p>
元素浮动之后会影响其后面的元素
为了清除某个元素浮动给它后面的元素造成的影响,需使用clear属性
clear:
1.left:清除设置了clear属性元素之前的元素左浮动的影响.
1.right:清除设置了clear属性元素之前的元素右浮动的影响.
1.both:清除设置了clear属性元素之前的元素左右浮动的影响.

1.清除浮动只是清除浮动造成的影响,并不会清除掉上一个元素的浮动效果
2.clear属性应该添加给被浮动影响的元素.
<p>浮动造成的影响02</p>
当父元素没有设置高度,则其高度由内容决定,此时如果
父元素里的元素再发生浮动,则父元素会出现"内容塌陷" 
解决办法:
1.给父级设置高度.(基本不用)
2.在浮动元素的后面加一个无内容的div标签并设置清除浮动.(建议使用第二个)
3.给父级添加overflow:hidden;属性强制父级检测其内部的内容高度.
<p>ps的使用</p>
1.四大面板:
字符:使用command+k调出常规设置面板,选择文字与标尺的单位改成像素.

历史记录:会记录所有的操作行为,可以快速回到某个操作时刻.
图层,属性,信息

抠图步骤:(普通png或者jpg或者gif图片)
1.通过选框工具选择要扣出的区域,可以通过变换选区调整区域大小.
2.拷贝当前选择的区域(command+c)
3.新建一个工作区(command+n),注意选择背景透明.
4.在新的工作区粘贴拷贝(command+v)
5图片保存,使用command+alt+shift+s保存为web格式,
如果是图标选择png-24的,因为它会按照之前选择的透明背景进行保存,
如果是大图背景图片,则选择jpeg格式进行保存.

抠图步骤:psd图
1.选择移动工具,并勾选自动选择且选择图层
2.点击想要扣出的图片区域,让系统自动选择对应的图层
3.按住command键点击已选区的图层缩略图,让系统自动框选对应的图片
4.拷贝选择的图片(command+shift+c)
5.新建一个工作区(command+n),注意选择背景透明.
6.在新的工作区粘贴拷贝(command+v)
7.图片保存,使用command+alt+shift+s保存为web格式,
如果是图标选择png-24的,因为它会按照之前选择的透明背景进行保存,
如果是大图背景图片,则选择jpeg格式进行保存.
<p>定位</p>
定位:对元素进行精准的位置调整
position
定位有四种方式:
1.static静态定位:默认的值,按照文档流结合元素自身的属性正常排布.
2.relative相对定位:
3.absolute绝对定位:
4.fixed固定定位:
要实现对应的定位效果,还需要配合着left,right,top,
bottom四个属性才可以实现元素的定位.

静态定位的例子:
我们以后不会设置一个元素的定位方式为static.
相对定位的例子:
1.相对定位不会脱离文档流,会保留之前所在的位置.
2.相对定位的元素所移动位置的参考是其之前所在的位置.
绝对定位的例子:
1.绝对定位的元素会脱离文档流,不保留之前的位置,如果
多个元素都绝对定位,则看书写顺序,谁写的晚,先显示谁.
2.绝对定位的元素所移动的参考位置是离其最近的设置了
非static定位属性的父级元素.如果所有的父级都没有
设置非static定位属性,则该元素相对于整个文档(document)定位.
固定定位例子:
1.固定定位的元素会脱离文档流,不保留之前自己的位置
2.固定定位的元素所移动的参考位置是相对于整个文档(document)定位的.
<p>垂直对齐</p>
1.文字的垂直居中
单行时,设置行高等于父级元素的高即可

2.图片的垂直居中
使用vertical-alicn:该元素定义行内元素的基线
相对于该元素所在行的基线的对齐方式.

值为:
baseline:基线对齐.
top:父元素content区域的顶端.
middle:元素的中线与所在行的基线对齐,
bottom:父元素content区域的低端;
text-top:文本的最高点topline与图片对齐.
text-bottom:文本的最低点bottomline与图片对齐.
super:与上标文字的基线对齐
sub:与下标文字的基线对齐

英语本-四线格自上而下:topline,middleline,baseline,bottomline.

1.如果图片的高度就是父元素的高度,
直接给图片设置vertical-align:middle即可 
2.如果图片的高度比父元素的高度小,
除了要设置图片的vertical-align:middle
还需要设置父元素的行高为整个父元素的高度.

3.块级元素(div)的垂直居中
给子元素设置绝对定位,top,bottom值都给0,
上下margin给auto,设置固定高度.
要居中的父级一定要设置非static的定位属性.
(一般会给relative,降低对父级元素的影响)
<p>100度练习</p>
处理文字,浮动在图片的右侧.
例子:
html代码:
ul&gt;li&gt;a+p{王府井希尔顿酒店}&gt;img
css样式:
/*处理四个宾馆区域*/
#hotHotel {
	padding:10px 0 -20px 0;
}

/*处理每一个li标签*/
#hotHotel li {
	width:144px;
	height:66px;
	float:left;
	margin:5px -6px 0 15px;
	background: rgb(58,58,58);
	
}
/*处理每一个宾馆图片*/
#hotHotel img {
	float:left;
	margin-right: 4px;
}
/*处理每一个图片文字*/
#hotHotel p {
	color:#fff;
	line-height: 20px;
	font-size: 12px;
	margin-top:20px;
}
<p>映纷视觉</p>
头部固定:
position:fixed;
由于固定定位脱离文档流的,如果后面的元素浮动,
浮动的元素也脱离文档流,这时先脱离文档流的就显示在下面.
此时需要考虑层级关系.
解决办法:
z-index:1000;
z-index的值越大,该层就越在上面.

maskLayer:遮罩层
html结构:div.div1&gt;div.div2
css样式:
.div1{
	width: 200px;
	height: 200px;
	background: gray;
	position: relative;
}
.div2 {
	width: 200px;
	height: 200px;
	position: absolute;
	top:0;
	left:0;
	visibility: hidden;
	background: yellow;
}
.div1:hover .div2 {
	visibility: visible;
}

浮动三个或三个以上的div怎么使靠左靠右的div紧靠
父级边框显示?
解决办法:
可以选择设置中间浮动div的左右margin值
<p>第十天:html5新标签</p>
HTML5:
1.新增了很多标签
2.支持本地持久化
3.摒弃了一些之前的css样式
4.增加了音频,视频标签
5.增加了canvas画布标签
*h5新增的一些标签或者功能目前只能在标准浏览器下支持.

语义化
标记标签 mark 双标签
用电量提示 meter
电量或者内存的使用情况
min:最小值
max:最大值
value:当前值
low:最低预警值
high:最高预警值
*默认的最小值是0,最大值是1
*如果当前浏览器不支持该标签,会显示标签里的内容.

单词内换行标签 wbr 双标签
拼音标注标签 ruby 双标签,
需要和rt,rp标签配合使用,
rt:在rt标签里写上需要标注的信息,
rp:当浏览器不支持时,会显示该标签里的内容.

datalist 双标签,一般结合input标签使用
1.在不同的浏览器下显示的效果有差异.
2.input标签和datalist标签是靠input标签内的list标签属性联系在一起的.
例子:
form&gt;input[type="text" list="city"]+datalist[id="city"]>option
<p>viewport</p>
viewport:为了使我们的网页兼容移动端
			
因为移动端设备的尺寸类型太多,所以我们如果
直接将网页版放置在移动设备上,会导致所有的
内容被压缩,用户体验差

viewport,是一个布局用的虚拟窗口,我们只需要适配
移动端的网页上加上view,纯pc端不需要viewport.
添加上viewport之后,网页上正常显示,不会被压缩,
但是需要用户滑动超出设备区域区域外的内容
viewport是一个属性,需要写在meta标签内.

viewport里的几个重要属性
1.width:viewport(虚拟区域的宽度)
2.initial-scale:原始缩放比例,一般写成1
3.minimum-scale:允许缩放的最小比例(不能小于0.01)
4.maximum-scale:允许缩放的最大比例(不超过10,一般2~3倍)
5.user-scalable:是否允许用户进行缩放,yes或者1代表允许;
no或者0代表不允许
<p>流式布局</p>
/*html标签再往上是文档对象document,
*文档的宽高就是浏览器窗口的大小.
* 窗口是可以伸缩的.
*/
流式布局也叫百分比布局
把元素的宽,高,margin,padding不再用固定数值,改用百分比,
这样元素的宽,高,margin,padding会根据页面的尺寸随时
调整已达到适应当前页面的目的.

*百分比是基于元素父级的大小计算得来的.
* 元素的水平或者竖直间距都是相对于父级的宽度计算的.(margin&padding)
* 边框不能用百分比设置
<p>em&rem</p>
em and rem
一个em单位表示当前元素的font-size值.
元素的font-size会继承.

一个rem单位相当于HTML标签的font-size值.
<p>媒体查询</p>
媒体查询
监听给定的设备的宽或者高,并设定临界值,可以处理
达到临界值之后页面的布局或者元素的属性.

语法结构:
@media 监听的设备类型 and (设置的临界条件){

}

/*only screen 电脑, pad,手机
* print:打印机
* speech:读音设备(阅读器)
* all:所有设备
*/

媒体查询属于css语法,需要写在style标签里.
<p>第十一天 伪类选择器</p>
伪类选择器
link:当连接未被点击过时的状态.
visited:当连接被点击过后的状态.
hover:鼠标移到元素上时的状态.
active:鼠标按下不放开时的状态.
CSS3增加了两个伪类选择器
1.target:只有跳转到该目标上,样式才会生效.
(一般有a连接参与,target是添加给跳转到的元素).
2.disabled:对属性为disabled的input标签生效.

相邻兄弟选择器
E+F {}
找到E元素下一个同级F元素.
CSS3新增的一个兄弟选择器
E~F{}
找到元素E后面与之同级的所有F元素.
<p>nth-child选择器</p>
/*E:nth-child(number){}
选择E元素所在的父元素里的
第number个元素,当第number个元素不是E元素时,不起效果
*/

/*
* E:nth-child(n){}
* n:代指所有的元素,从第一个直到最后.
*/

/*
* E:nth-child(2n+1){}
* 2n+1=odd
* 选中E元素所在父级里所有编号为奇数的E元素.
*/

/*
* E:nth-child(2n){}
* 2n=even
* 选中E元素所在父级里所有编号为偶数的E元素.
*/
/*
* E:nth-child(-n+8){}
* 编号8之前的E元素.包含8
*/
/*
* E:nth-child(n+8){}
* 编号8之后的E元素.包含8
*/
/*
* E:nth-of-type(number)
* type关心类型
* 获得E元素所在父元素里剔除了不是E元素之外的所有E元素
* 之后的第number个E元素.
*/

/*E:nth-last-of-type(2){}
* 获得E元素所在父元素里所有的剔除了不是E元素之外的所有元素
* 之后的第number个E元素.(到着数)
*/
/*
* root:会直接找到html标签
* E:empty 选择内容为空的E元素.
*/
例子:
:root {
		background: orange;
	}

/*E:only-child 匹配父元素仅有的一个子元素E。
*要使该属性生效，E元素必须是某个元素的子元素，
*E的父元素最高是body，即E可以是body的子元素
*/
<p>阴影</p>
/*阴影
* box-shadow:
* 1.x方向的偏移度
* 2.y方向的偏移度
* 3.阴影的发散度(模糊程度)
* 4.阴影的宽度(大小)
* 5.阴影的颜色
* 6.inset:添加之后,阴影在元素内部.
*/
/*box-shadow可以添加多组值,如果有多组值,组与组之间用逗号隔开.
*/
<p>圆角</p>
/*圆角border-radius
* 圆角分四个位置:
* top-left,top-right,bottom-left,bottom-right,
* 如果要用圆角画出标准的圆形
* 1.元素尺寸宽高相等
* 2.每个圆角的水平和竖直半径同时为宽或高的一半.
*/

/*
* 当统一写全部的角时,水平方向的写在一起,竖直方向的写在一起,
* 中间用/分隔开.当单独写某一个角的水平竖直值时,只需要用空格隔开即可.
*/
/*如果给三个值,分别对应:左上,右上+左下,右下.
* 如果给两个值,分别对应:左上+右下,右上+左下.
*/
<p>背景</p>
background-origin:第一张图片的起始位置.
1.border-box:从边框开始
2.padding-box:默认从padding开始
3.content-box:从内容开始

background-clip:背景剪裁.
1.border-box:从边框开始
2.padding-box:默认从padding开始
3.content-box:从内容开始

/*常用的浏览器内核
* -webkit-:safari,chrome的内核
* -moz-:火狐的内核
* -ms-:IE的内核
* -o-:欧鹏的内核
*/
<p>背景蒙版</p>
背景蒙版:
1.只有chrome浏览器支持
2.蒙版图片必须是png图片,jpg的不行.
3.设置成蒙版的图片,系统会把原来不透明的部分处理成透明的部分,
透明的部分处理成不透明的.

/*设置蒙版*/
-webkit-mask-image: url(haha.png);
/*蒙版的位置
 * x轴的偏移量
 * y轴的偏移量
 */
-webkit-mask-position:120px 130px;
<p>background支持多个值</p>
background支持多个值,一般应用在背景图片的拼凑上
1.如果写多组值,可以理解成先写谁,谁在上面.
2.每组值用逗号隔开,最后一组加分号.
例子:
background:url(../day01/img/try.png) no-repeat left top,
url(../day01/img/try.png) no-repeat right top,
url(../day01/img/try.png) no-repeat left bottom,
url(../day01/img/try.png) no-repeat right bottom,
url(../day03/作业/code.png) repeat center center;
<p>渐变</p>
渐变:
1.线性渐变
2.径向渐变
3.重复渐变
*渐变相当于一个元素的背景图进行设置.
* 要实现渐变,至少要有两种颜色.

1.线性渐变:兼容性不好,需要前缀添加内核.
写法1:background:linear-gradient(方向,颜色1,颜色2,颜色3...);
写法2:background:linear-gradient(方向,颜色1 开始渐变位置(百分比),...);

2.径向渐变
呈圆形的一种渐变方式
background:
radial-gradient(半径 形状(圆形或者椭圆形) at 圆心,颜色1 位置1,...);

1.半径:
farthest-side(最远边),
farthest-corner(最远角),
closest-side,closest-corner.

2.形状:circle(圆形),ellipse(椭圆形).
3.at 别忘了
4.圆心:(x,y)给具体的px值,默认在元素的中心点;
给具体的单词方位:left,right,top,bottom,center
***
* 如果选择上述对应的组合,
* 那么半径选择时不要选择最近边和最近角(造成半径为0),
* 不会显示渐变.

重复渐变
1.重复线性渐变
*语法跟线性渐变一样,唯一区别就是当出现纯色时,重复线性渐变不会显示纯色,
* 而是再出现一组渐变.
background: -webkit-repeating-linear-gradient
(left,#fff 0%,#fff 10%,transparent 10%,transparent 20%);
2.重复径向渐变.
*语法跟径向渐变一样,唯一区别就是当出现纯色时,重复径向渐变不会显示纯色,
* 而是再出现一组渐变.
<p>倒影</p>
倒影
*关于倒影的渐变,只能设置不透明颜色和透明颜色之间的渐变
* 1.兼容性不太好,webkit内核支持
* 2.倒影只是一个映像,不占空间.
* 语法规则:
* box-reflect:倒影的位置与实物的距离(像素值px) 渐变/蒙版
* 位置:
* below:在XX的下面
* ablove:在XX的上面
* left:左边
* right:右边
ps:
-webkit-box-reflect:below 10px 
-webkit-linear-gradient(transparent,transparent 50%,
rgba(255,255,255,0.3));
<p>景深</p>
景深:当前视点的远近(眼睛到所看物体的距离),默认的景深是0,
perspective:1000px;
<p>2D变换</p>
类型:
1.平移:translate(x,y)
translateX(),translateY()
值可以是具体的px单位值,也可以是百分比.
百分比是依据对应元素的宽高计算得来的

/*平移
 * 如果需要多个值参与的2D或者3D变换,
 * 要把多个值全部写在一个transform属性里.
 * 如果写多个,后面的会覆盖前面的.
 */

2.缩放:scale(x,y)
值我们一般给小数,
1缩放为原来的1倍,0.5缩放为原来的一半,2缩放为原来的2倍.
如果值为负,先按照对应的轴翻转,再缩放.
3.倾斜:skew()
skewX 按照x轴倾斜
skewY 按照y轴倾斜
值是角度 单位是deg

倾斜的坐标轴与我们认知的坐标轴正好相反,横的是y轴,竖的是x轴.

沿x轴给正值,逆时针旋转.
沿y轴给正值,顺时针旋转.

4.旋转:rotate(x,y)
rotateX:沿x轴旋转
rotateY:沿y轴旋转
值给对应的角度,单位deg


从x轴正方向向零点看,如果沿x轴旋转给正值,是顺时针,给负值是逆时针.
从y轴正方向向零点看,如果沿y轴旋转给正值,是顺时针,给负值是逆时针.
<p>3D转换</p>
/*如果想看元素展现的3D效果,
*需要激活当前界面的3D效果,
*而且要加到对应元素的父级里.
*transform-style:preserve-3d;
*/
3D多了一个z轴可以展示立体效果
translate平移
translateZ()
rotate旋转 
rotateZ()
值为正,顺时针旋转,值为负,逆时针旋转
<p>动画</p>
动画分为:
1.css动画
	a.过渡动画
	b.关键帧动画
2.js动画
3.第三方动画

过渡动画
语法:	
1.要进行变化的属性(transition-property)
2.动画的持续时间(transition-duration)
3.变化曲线transition-timing-function
4.延迟时间transition-delay

*过渡动画当失去触发时机时,会恢复到原来的状态.
*触发过渡动画的时机:
*1.hover (最常用)
*2.focus 当输入框或的焦点时.
*3.checked(选框被选中时)
*4.媒体查询
*5.js

/*transition-property*/
/*过渡属性可以填多个值,值与值之间用逗号隔开
* all表示所有的属性
*/

/*变化曲线的值:
*ease:默认值,先快再快再慢;
ease-in:淡入(动画刚开始的时候变化慢);
ease-out:淡出(动画快结束的时候变化慢);
ease-in-out:淡入淡出(开始慢,中间快,结束慢);
linear:线性(匀速);

贝塞尔曲线:cubic-bezier(X1,X2,Y1,Y2);
这四个值取值范围为0~1,所有的变化都可以用贝塞尔曲线代替.

ease函数等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0)
linear 函数等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0)
ease-in 函数等同于贝塞尔曲线(0.42, 0, 1.0, 1.0)
ease-out 函数等同于贝塞尔曲线(0, 0, 0.58, 1.0)
ease-in-out 函数等同于贝塞尔曲线(0.42, 0, 0.58, 1.0)
*/

/*合写
多个值中间用空格,没有顺序限制,但是要注意如果写了两个秒数,
系统会把第一个当做动画执行时间,第二个当做延迟时间.
*/
transition: all 5s linear 1s;

<p>关键帧动画</p>
关键帧动画:在规定的动画时间内,一次动画可以做多种变化
animation
语法格式:
1.animation-name:动画的名字,配合keyframes使用,动画名字是我们自己起的.
2.animation-duration:动画的持续时间
3.animation-iteration-count:重复次数,默认一次.infinite无限次
4.animation-delay:动画延迟时间.
5.animation-direction:动画播放的方向
	a.normal正向播放
	b.reverse:反向播放
	c.alternate 奇数次正向,偶数反向
	d.alternate-reverse 偶数次正向,奇数次反向.
6.animation-play-state:动画的状态
    a.paused
    b.running 播放
7.animation-fill-mode:设置动画以外的状态,
	a.none 不设置,完成后回到原始状态
	b.forwards 保存最后一帧
	c.backwards 动画结束后,快速回到原始状态.
	d.both 具备forwards 和 backwards的特点.

动画效果由@keyframes决定.
1.@keyframes要写在css样式里面
2.@keyframes 中的动画名要和animation-name的名字一样.

格式一:
@keyframes 动画名 {
from{修改的属性值}
百分比{修改的属性值}
to{修改的属性值}
}
<p>自定义字体</p>
自定义字体:
给下载的或者我们自定义的字体声明一个名字,
方便我们以后的引用,引用时需要告诉系统文字的路径.
语法:@font-face {
	font-family:我们自己起的名字.像Yfont
	src:自定义文字包的路径.
	/*兼容IE高版本的写法*/
	url(自定义字体);
}
文字的字体包(字体文件):格式:
1.ttf:最常用.chrome,Safari,Opera,
Firefox,iOS,Android都支持该类型的字体包.
2.eot:仅IE浏览器支持.
3.svg:应用ios
4.woff:chrome和Firefox.
<p>文字的多列显示</p>
/*文字的多列显示
 * column复合属性
 * 1.column-count:最大列数
 * 2.column-width:最小列的宽度
 * 3.columns:是column-count和column-width缩写
 * 4.column-gap:列与列之间的距离.
 * 5.column-rule:分割线
 * 	a.column-rule-width
 *  b.column-rule-style
 * 	c.column-rule-color
 * 6.column-span:是否允许跨列,两个值,默认为1,all为跨所有列
 */
 <p>背景透明文字不透明</p>
 解决办法1:
 使用background:rgba();
 不使用background:颜色;opacity:0~1;
 解决办法2:
 一个div上有另外一个包含文字的div,下层div设置opacity.
 <p>resize</p>
 /*resize:
1.none:不允许元素改变大小;
2.vertical:只允许元素在竖直方向上改变大小;
3.horizontal:只允许元素在水平方向改变大小;
4.both:允许元素水平竖直都可以改变大小;
IE和Opera不兼容resize属性.
*/
resize:both;
/*如果要使元素的resize属性起作用,必须加溢出隐藏*/
overflow: hidden;
<p>弹性布局</p>
布局方式:
固定布局:
浮动布局:
响应式布局:
流式布局:
弹性布局:

如何开启弹性布局
display:flex
注意:该元素内部的子元素的float,clear,vertical-align属性统统失效
概念:
容器:开启了弹性布局的元素
弹性子元素:容器里的子元素

主轴:所有弹性子元素会从主轴的起点开始一直按顺序排布到主轴的终点
侧轴(交叉轴):与主轴垂直的轴

容器的属性:
元素排布方向
flex-direction:主轴的方向
a.row(默认值):水平方向,从左往右
b.row-reverse:水平方向,从右向左
c.column:竖直方向,从上到下
d.column-reverse:竖直方向,从下往上

换行方式:
flex-wrap:
1.nowrap:不换行(默认)
2.wrap:会换行.换的行会在原来的下面.
3.wrap-reverse:换行,换行会在原来的上面.

弹性子元素在主轴上的对齐方式:
justify-content
1.space-between:两端靠边,其余元素的间距相等
2.space-around:所元素左右间距相等
3.flex-start:向主轴的起点对齐
4.flex-end:向主轴的终点对齐.
ps:flex-flow:flex-direction和flex-wrap的简写.

弹性子元素在侧轴上的对齐方式:
align-items:
1.flex-start:向侧轴的起点对齐
2.flex-end:向侧轴的终点对齐
3.center:向侧轴的中心点对齐
4.baseline:文字的基线对齐
5.stretch:如果弹性子元素不设置宽高,高度填满整个侧轴(默认值)

弹性子元素的属性
order:顺序数值,决定元素的排列书序,默认值为0.值越小位置越靠前,值相等,由
书写的顺序决定,写的早,靠前.
flex-grow:多余空间的分配比例,默认0,代表不使用多余空间.

flex-shrink:当空间不足时,收缩的比例,默认是1,
当前数值为0代表空间不足也不缩放.

flex-basis:弹性子元素占主轴上的宽度,相等于width.该值用于计算主轴上
是否还有剩余空间.

align-self:单独调整弹性子元素在侧轴上的对齐方式.
1.center
2.flex-start
3.flex-end
<p>js第1天(js的介绍)</p>
JavaScript,一种脚本语言,也属于编程语言,负责网页的相关行为和动作.

什么是编程语言?
标准:是否具有"图灵完备".
图灵完备:可以执行任何的计算.

什么是脚本语言?
传统的编程语言(c语言):编写>编译>链接>可执行的文件

JavaScript 脚本语言省去了传统编程语言繁琐的过程,
使用JavaScript写出的代码,就是最终要执行的文件.

JavaScript的组成部分:
1.ECMAScript:ECMA(欧洲计算机协会),基本的语法结构,基本的对象.
2.DOM:文档对象模型,描述处理文档内容的方法.
3.BOM:browers object model,浏览器对象模型,描述与浏览器进行
交互的方法.

JavaScript的特点:
1.解释性执行,脚本语言
2.面向对象,一切事物皆对象
3.弱类型,没有严格的数据类型
4.事件驱动,由事件触发执行
5.跨平台.

js的注释分两种:
1.单行注释//
2.多行注释/**/
不可嵌套注释

1.基本语法:
a.外部导入js,新建一个js文件,
使用&lt;script src="*.js"&gt;&lt;/script&gt;的方式导入外部js文件
b.内部js,把所有与js有关的代码用&lt;script&gt;&lt;/script&gt;包裹
嵌入到html文档里面.

2.js的输出方式
1.alert(),显示带有指定内容和一个ok按钮的警告框.
2.console.log(),会在控制台输出内容,多用于代码测试.
3.document.write(),向html文档中写内容.
4.innerHTML,向元素内容里写入内容.(必须先找到对应的内容)
5.修改元素的属性值.
6.修改元素的样式.

3.常量:在程序运行期间,不可改变的量.
a.数字常量:1,10,0.5,-8,1e4
b.字符串常量:"字符串可以是双引号引起来",'也可以是单引号'.
双引号不可以嵌套双引号,单引号不可嵌套单引号
双引号可以嵌套单引号,单引号也可以嵌套双引号

4.变量:在程序运行期间,可以改变的量.
变量一种存储数据的容器.
变量需要定义:
	var 变量名 = 初值;
	变量名的命名规则:
	a.由数字(0-9)字母(a-z,A-Z),下划线(_),美元符号($),组成,
	数字不能开头
	b.不同于系统的关键字重名(看颜色),
	c.见名只意
	d.驼峰命名法,帕斯卡命名法,匈牙利命名法

5.原始数据类型:
	 a.number数字类型
	 b.string字符串类型
	 c.boolean 布尔类型
	 d.null  空置类型
	 e.undefined 未定义类型
	 f.object 对象类型
	 注意:js里数据类型由赋的值决定.

6.运算法:
	 规范:运算符两端加空格.
	 a.算数运算符(+,-,*,/,%,--,++)
	 b.赋值运算符(=,+=,-=,*=,/=,%=).
	 c.关系运算符(>,<,>=,<=,==,===,!=,!==)
	 d.逻辑运算符(&&,||,!)

转义字符:\内容,输出时会输出斜杠后面的内容,
特殊的:
\n 代表换行
\t缩进一次tab键的距离

js到底是如何影响元素的?
js设置样式的本质就是在往行间写style(标签内)

交换两个变量里的值;
先把任意一个变量里的值赋值给一个临时变量
在进行交换,对角线法则.
var a = 10,b=5,c;
c = a;
a = b;
b = c;

如果要连续定义多个变量,用逗号隔开,只需要在最开头
写var即可

<p>变量命名规范</p>
//驼峰法
var appleCount = 10;
//帕斯卡
var AppleCount = 20;
//匈牙利命名法
var iAppleCount = 30;

获取变量的类型 typeof,注意:如果使用typeof测试null类型,显示object

<p>类型转换</p>
类型转换(显示转换)
Number('12');
String(true);
//非0即为真
var n3 = Boolean(-1);
console.log(n3);//true

类型转换(隐式转换)
当"+"运算符两端,一个是数字,一个是字符串时,做的是字符串的拼接
var k = 10 +"123";
console.log(k);

当"-,*,/,%"运算时,两端一个是数字,一个是字符串,做的算数运算
var k1 = 12 -'3';
console.log(k1);

当除数为0时,执行除法得到的结果为无限大,执行取余得到的结果为NaN.

<p>运算符</p>
1.算术运算符
2.关系运算符
3.赋值运算符
4.逻辑运算符

++ 自加运算
++a;//等价于 a = a + 1;
f = b++;//等价于f = b;b = b + 1;
++(--)在前,先+1(-1),再运算;++(--)在后,先运算,再+1(-1)

===(!==)在做比较时:
先比较两侧的数据类型是否一致,不一致,返回false(true),
如果一致在比较内容;

==或者!=在做比较时:
当数据类型不一致时,先把两侧的数据类型化为一致,再比较.

逻辑与 &&,运算符两端同时成立(为真),整个运算结果才为真,否则,运算结果为假.
逻辑或 ||,运算符两端同时为假时,运算结果才为假,否则运算结果为真.
逻辑非 !,逻辑否定,黑白颠倒
逻辑与和逻辑或的短路现象
<p>js第2天-语句</p>
表达式:
由常量,变量,运算符组成的就是表达式
表达式都有结果.

表达式根据结果可以分为两类:
整型表达式  a + 5
条件表达式  a > 5

语句
语句是代码执行的最小单位
注:每条语句都会以分号结尾,js里的分号
可以省略,但是建议加上分号.

程序运行的三大结构:
1.顺序结构:代码从上到下,从左到右依次执行(不重不漏).
2.分支结构:根据不同的情况,执行不同的代码.
3.循环语句:重复执行某段代码.

解释三大结构:
1.顺序执行
2.分支结构
1.if语句
2.switch语句
			
1.1-if语句的第一种结构
if(条件表达式){
  语句块;
}

1.2-if语句的第二种结构
if(条件表达式){
  语句块1;
}else{
  语句块2;
  }

1.3-if语句的第三种结构
if(){
	
}else if(){
	
}else{
	
}

switch...case语法:
switch(整形表达式) {
    case 值1: {
         语句1
         break;
    }
     case 值2: {
         语句1
         break;
    }
	case 值3: {
         语句1
         break;
    }
	...
	default: {
       默认语句
       break;
	}
}
计算整形表达式的值,然后跟case后面的值进行匹配,如果匹配上,
执行对应case大括号内的语句.如果一个都没有匹配上,
执行default大括号里面的语句.
break关键字在switch..case语句里的作用是跳出整个switch语句.

Math.random() 随机出一个[0, 1)的数
使用Math.random()方法产生的数字的位数,与我们直接写出的小数的位数是不同的,不定.
Math.random() * n得到[0, n)之间的一个数.
	    	 
console.log(Math.floor(Math.random() * 100));

如果要求[n, m]之间的随机数
Math.floor(Math.random() * (m - n + 1) + n);
<p>三目运算符</p>
条件运算符(三目运算符) 等价于if...else
条件表达式 ? 表达式1 : 表达式2; 
如果条件表达式为真,整个运算的结果为表达式1的结果;
如果条件表达式为假,整个运算的结果为表达式2的结果.
条件表达式也可以嵌套使用.
<p>js第3天(三大循环结构)</p>

1.for循环(80%)
2.while循环(15%)
3.do...while循环(5%)

for循环语法:
for(1; 2; 3) {
    4;
}
1.循环变量初始值
2.循环条件
3.循环增量
4.循环体

for循环的执行顺序
第一次:1243
以后:243

题1:随机10个[30, 70]的随机数,输出随机数里的最大值.
题2:随机10个[30, 70]的随机数,输出随机数里的最小值.
总结:
 * 1.求最大值.参考值要保证比随机的最小值还要小.
 * 2.求最小值.参考值要保证比随机的最大值还要大.

 
break:跳出本层循环.
continue:跳过本次循环.继续进行下一次循环.
 
for (var i = 1; i <= 20; i++) {
  if (i = 13) {
    continue;
  }
  console.log(i);
}

<p>while循环</p>
while循环的语法:
1
while(2){ 
    3;
    4;
}
1.循环变量初始值
2.循环条件
3.循环增量 
4.循环体
while循环的执行顺序:
第一次:1243
以后:243
判断循环条件是否成立,如果成立,就执行循环体,否则,循环结束.

何时用for,何时用while???
答:当知道循环次数时用for.不知道循环次数时用while.

do...while循环
语法:

1
do {
   4;
   3;
}while(2)
do...while的执行顺序
第一次 1432
以后 432
先执行循环体,再判断循环条件,如果成立,再执行循环体,如果不成立,跳出循环.
<p>js第4天(数组)</p>
数组:用于存放大量数据的有序集合.

语法:
var 数组名 = [值1,值2,值3...];
注:数组可以存放不同类型的数据.(包括表达式)

如何使用数组?(如何获取数组中的数据)

访问数组中的元素格式:
数组名[下标]
下标是从0开始的
如果要遍历数组中的元素,通常会和循环结合使用

数组中的元素,如果某些元素不赋值,系统会将其判定为undefined类型
数组中的元素,如果全部写逗号,系统会忽略最后一个逗号.
<p>函数</p>
函数function
具有特定功能的代码块
特点:
1.把代码封装起来,方便以后用.
2.函数定义时,函数的代码块不会执行,只有调用该函数时,
函数内的代码才会执行
3.使用函数封装起来的代码具有复用性.

函数包含两部分
1.函数的定义(函数的声明);
2.函数的调用

函数的语法:
function 函数名(参数1,参数2,参数3....){
	语句
 return 返回值;
}

函数的基本分类:
根据有无参数,有无返回值,可以将函数分为4大类
1.无参数无返回值
2.无参数有返回值
3.有参数无返回值
4.有参数有返回值
形参:形式参数,在函数定义时的参数,没有确定的值
实参:实际参数,函数调用时的参数,有确定的值;在函数调用时,实参的值会传给形参
有无参数,取决于调用该函数时,是否需要从外界提供数值来保证函数内代码块的执行.
有没有返回值取决于是否需要在外部使用函数内计算的结果.

如果在函数调用时,少写某些参数,参数值为undefined,如果多写,多余的会被系统忽略.

arguments,函数调用时,传入的所有实参,会被存放在arguments数组里,
当我们不确定函数的参数应该有几个时,可以通过arguments数组获取所有的参数.

函数.name 会返回函数名对应的字符串
函数.length 返回对应函数的形参个数.
arguments.length 返回对应函数的实参个数.

函数内return的作用:
1.将函数的计算结果返回给外界.
2.return后面的语句不会被执行.

js变量的作用域:
1.js里没有块级作用域.
2.js里有的是函数作用域.
全局变量:定义在函数外部的变量.
局部变量:定义在函数内部的变量.
ps:
1.在函数的内部,既可以访问全局变量,也可以访问局部变量
2.在函数的外部,只可以访问全局变量
3.当局部变量与全局变量重名时,以局部变量为准.

js变量的生命周期:
变量在内存中存放时间的长短.
全局变量:直到页面关闭之前,页面关闭之后被删除.
局部变量:直到函数运行完之前存在,执行完后被删除.

匿名函数:
 (function (name){
	console.log("这是一个匿名函数"+"+"+name);
 })("贾某某");


函数表达式:

var jia = function (name){
 	console.log("这是一个匿名函数"+"+"+name);
};
jia("贾某某");
<p>js第5天</p>
函数分两类:
1.库函数,系统已经写好的函数
2.自定义函数.
<p>字符串操作函数</p>
获取子字符串(一个字符串的一部分);
substr(start,length);
1.start:截取字符串的起始位置,最开始是0;如果给负值,从后往前数位置.
2.length:截取的字符串长度.如果不写,系统会从起始位置一直截取到最后.

根据对应的字符将字符串分割成数组.
split(string,count);
1.string:分隔符,如果用"",会把原有字符串里的每一个字符进行分割.
2.count:分割后的数组的元素个数.如果不写,默认分割成几个就几个.
<p>通过js获取元素的方式</p>
通过js获取元素的方式:
1.getElementById(),通过id获取元素,id是唯一值.
2.getElementsByClassName(name):
获取class为那么的所有元素,返回值为一个数组.
3.querySelector():通过标识符(选择器)获取对象(单个对象(第一个))
4.querySelectorAll():获取某标识符下的所有对象,返回值是一个数组.
5.get.ElementsByTagName(tagName)
获取到标签名为tagName的所有对象,返回值是一个数组.

封装一个函数玩玩:
function getElement(name){
	var name = name.split(" ");
	if(name.length > 0){
		name = name.join(" ");
		return document.querySelectorAll(name);
	}else{
		name = name.join(" ");
		if(name.substr(0,1) == "#"){
			return document.querySelector(name);
		}else{
			return document.querySelectorAll(name);
		}
	}
}
<p>鼠标移入移出</p>

鼠标移入事件
1.onmouseover
2.onmouseenter
onmouseenter,onmouseleave 兼容性更好

<p>定时器</p>
定期执行某个函数(定时器)
setInterval(codeString,time);
1.codeString:需要执行的代码字符串;
2.time:时间间隔.单位毫秒. 1s = 1000ms

清除一个计时器
clearInterval(之前声明的计时器存储变量位置);
<p>数组操作函数</p>
数组操作函数
1.push()
向数组的尾部添加元素,理论上可以添加无数个,返回添加后数组的元素个数.
2.pop()
移除数组里最后一个元素,并把移除的元素返回.
3.slice(start,end)
获取数组中的某些元素,并组成一个新的数组,
start和end从0开始计算,不包含end位置上的元素.

4.unshift(ele1,ele2,ele3...)
向数组的头部添加元素,并返回添加后数组的元素个数.
5.shift()
删除数组里的第一个元素,并返回删除的元素.
6.sort()
对数组进行排序
默认的排序方式是升序排序,且是对字符串进行的排序,按ASCII码进行排序.
数字字符 < 大写字母 < 小写字母
逐个字符进行比较,如果遇到字符相同,比较下一个字符.
7.concat()
把数组与另外一个数组进行拼接,形成一个新的数组.
8.join(string)
将数组中的元素拼接成一个字符串.
string:连接符,如果不写,默认的连接符为逗号.

*冒泡排序:
var array = [5,4,3,2,1];
for(var i = 0;i < array.length-1;i++ ){
	
	for(var j = 0;j < array.length-i-1;j++){
		
		if(array[j] > array[j + 1]){
			//交换位置
			var temp = array[j];
			array[j] = array[j + 1];
			array[j + 1] = temp;
		}
		
	}
}
console.log(array);

趟数 次数
 1    4
 2    3
 3    2
 4    1
...  ...
n代表总个数.
n-1  n-(n-1)

在sort()函数里传入比较函数,比较规则.
function ascending(a,b){
	//a,b代表相邻的两个元素.
	return a > b;
}
array.sort(ascending);
<p>常用的数学函数</p>
Math.floor()向下取整
Math.random()随机数
Math.abs() 绝对值
Math.ceil()向上取整
Math.round()四舍五入

Math.max() 求多个数的最大值
Math.min() 求多个数的最小值
Math.pow(x,y) 求x的y次方
Math.sqrt() 开平方
<p>js第6天=>日期Date</p>
在js里,Date用来表示时间和日期.
1.获取当前时间
var now = new Date();
2.获取年份
var nowYear = now.getFullYear();
3.获取月份 月份值是 0-11
var nowMonth = now.getMonth();
4.获取当天
var today = now.getDate();
5.获取星期几
var day = now.getDay();
6.获取小时
var hour = now.getHours();
7.获取分钟
var minute = now.getMinutes();
8.获取秒
var second = now.getSeconds();
9.获取时间戳 以毫秒做单位(1970.1.1 00:00距离现在的时间)
var time = now.getTime();
<p>闭包</p>
声明在一个函数里的函数叫闭包.
在闭包的内部可以访问其外部函数里定义的局部变量.

闭包的两个作用:
1.可以通过闭包获取函数内的局部变量.
2.通过闭包可以保证局部变量的生命周期与整个网页的生命周期一样.
<p>this</p>
一个函数里的this表示的是会触发该函数的元素
1.去找this在哪个函数里面
2.去找谁会触发这个函数
<p>js第7天=>js版时钟</p>
1.布局
2.js操作,Date对象的使用练习
<p>碰壁效果</p>
碰壁效果
1.控件布局
2.移动
  a.水平移动
  b.竖直移动
3.控制边界
4.反弹
<p>图片无限播放</p>
 * 1.当最后一张图片滑离边界的时候,后面还有图片(第一张,第二张)
 * 2.当第一遍内容走完时,迅速改变content的x轴的位置
 */

//声明一个变量,记录x轴的坐标
var x = 0;
//获取到要移动的元素
var contentDiv = document.getElementById("content");
//复制当前元素里的内容拼接到当前内容后面
contentDiv.innerHTML += contentDiv.innerHTML;
//获取到所有的图片
var imgs = contentDiv.getElementsByTagName("img");
contentDiv.style.width = imgs[0].offsetWidth*imgs.length+"px";
//图片运动的函数
function scroll(){
	x--;
	contentDiv.style.left = x + "px";
	//如果达到了第一遍图片的最后,迅速调整x的值为0
	if(x == -imgs.length/2*imgs[0].offsetWidth){
		x = 0;
	}
}
setInterval(scroll,10);
<p>js第8天=>tween.js</p>
</pre>
<a href="http://www.cnblogs.com/cloudgamer/archive/2009/01/06/Tween.html">
	tween.js使用教程
</a>
<pre>
缓动函数(补间动画)===>过渡动画
1.第三方动画 tween.js
2.实现:缓动公式(效果:控制物体在某个时间段内的运动速度)
缓动函数:
1.linear 匀速
2.Quad 二次方缓动效果
3.Cubic 三次方缓动效果
4.Quart 四次方缓动效果
5.Quint 五次方缓动效果
6.Sine  正弦缓动效果
7.Expo  指数缓动效果
8.Circ  圆形缓动函数
9.Elastic 指数衰减正弦曲线缓动函数
10.Back  超过范围的三次方的缓动函数
11.Bounce 指数衰减的反弹曲线缓动函数
每种缓动函数都由三种效果:
1.easeIn  加速
2.easeOut 减速
3.easeInOut  先加速后减速
注:linear 只有一种效果匀速

每个函数都有四个参数:
1.t====>开始的步数(从0开始)
2.b====>开始量(开始的属性值)
3.c====>改变量(属性值的改变量):结束位置的属性值 - 开始位置的属性值
4.d====>结束的步数(运动的总时间)

注意:当开始步数增加到与结束步数相等时,整个运动结束.
注注意:只有当t增加到与d相等时才会结束运动;如果不等,运动不会停止.
tween.js的使用
1.下载
2.引入
3.使用tween.js语法
Tween.缓动函数名.缓动效果名(t,b,c,d);
<p>使用tween.js实现图片无限轮播</p>
<p>导航条效果,下有滑动线</p>
<p>轮播图,可点击,悬浮停止计时器,</p>
<p>js第9天=>京东版轮播图</p>
<p>dom基础,DOM基础</p>
js的组成部分
1.js基础部分
2.DOM
3.BOM
DOM:document object Model 文档对象模型
提供了访问html文档的方法,允许对html进行增删改查.
DOM树:当网页加载完成后,浏览器会创建一个树状的结构.
DOM树状结构中,包含很多节点.
节点的类型:
1.元素类型&lt;div&gt;,&lt;p&gt;,&lt;a&gt;
2.文本节点 "hello,world"
3.注释节点 &lt;!--注释--&gt;
4.文档类型 document
5.声明节点 &lt;!DOCTYPE html&gt;

节点之间的关系:
1.父节点
2.子节点
3.兄弟节点

<p>查找元素节点</p>
1.通过id查找对应的元素节点,返回的是一个节点.
document.getElementById()
2.通过类名查找元素节点,返回的是包含一个或者多个节点的数组
document.getElementsByClassName()
3.通过标签名查找元素节点,返回的是包含一个或者多个节点的数组
document.getElementsByTagName()
4.通过选择器查找查找元素节点,返回的是包含一个或者多个节点的数组.
document.querySelectorAll("#p1");
5.通过选择器查找匹配到的第一个元素节点
document.querySelector(".box");
<p>特殊节点</p>
1.document 文档节点
2.document.documentElement ==> html节点
3.document.body ==> body节点
4.document.head ==> head节点
5.document.doctype ==> 声明节点
<p>通过节点之间的关系获取节点</p>
1.获取某个节点的子节点(返回的是一个数组)childNodes
2.获取某个节点的父节点(只有一个)parentNode
3.获取到第一个子节点firstChild
4.获取到最后一个子节点lastChild
5.获取前一个兄弟节点previousSibling
6.获取后一个兄弟节点nextSibling
7.获取上一个兄弟标签元素previousElementSibling
8.获取下一个兄弟标签元素nextElementSibling
需要注意的是，在IE下会直接跳过HTML中的空格/Tab/换行，
而Firefox下空格会认为是一个节点，
因此，对类似节点取nextSibling或previousSibling时，
需要判断是否是元素节点
var el = $('#demo');
do {
	el = el.nextSibling;
} while(el.nodeType != 1);
<p>节点信息</p>
1.nodeValue 节点的值
2.nodeType  节点的类型
3.nodeName节点名字
4.获取元素节点的内容(开始标签与结束标签之间的内容)
a:innerHTML,获取标签里的所有内容 包含文本节点,元素节点,注释节点等(everything)
b:innerText,去掉空格并获取标签里的文本节点,不会显示被隐藏了的元素的文本内容.
注:display,visibility,隐藏的不会被显示,但是opacity隐藏的会被显示
c:textContent:获取文本节点的内容,保留空格,会显示被隐藏了的元素的文本内容.

nodeType
1代表元素节点
3代表文本节点
8代表注释节点
9代表文档节点
10代表声明节点

nodeName
元素节点:元素的标签名(全大写)
文本节点:#text
注释节点:#comment
文档节点:#document
类型节点:html

//hasChildNodes()判断一个节点是否有子节点

元素属性的操作
1.setAttribute 设置某个元素节点的属性
2.getAttribute获取某个元素节点的属性值
3.removeAttribute删除某个元素节点的属性

元素节点的样式
1.style 获取标签内部的样式,所有的内部样式都会展示
2.获取所有的样式
	a.仅支持IE===>currentStyle
	b.支持IE以外的所有浏览器===>getComputedStyle(元素,伪类)
3.获取指定的某一个样式
div.style.width行内样式
getComputed(div).width     //获取所有的样式
getComputed(div)["width"]    //获取所有的样式


<p>创建节点和添加节点</p>
创建节点
1.创建元素节点createElement()
2.创建一个注释节点createComment()
3.创建文本节点createTextNode()
将创建好的节点插入到对应的位置
1.将创建好的节点放到对应节点的最后面
例子:document.body.appendChild(img);
2.在某个节点之前插入对应的节点
insertBefore(a1,a2)在a2节点之前插入a1节点
例子:document.body.insertBefore(imgOne,div4);
3.替换节点 replaceChild(a1,a2);用a1替换a2
例子:document.body.replaceChild(span,div4)
4.删除节点 removeChild(Node);
例子:document.body.removeChild(img);
<p>DOM联动菜单</p>
当第一个选择框被修改时,清空第二个选择框里的选项,
并通过第一个选择框的选项给第二个选择框创建对应个数的option选项卡.
<p>js第10天</p>
<p>节点的位置和尺寸</p>
1.内尺寸(不包含滚动条,但是pc端有可能因为浏览器版本问题导致系
	统将导航条的宽度计算在内尺寸)
clientHeight = content.height + padding.top + padding.bottom;
clientWidth = content.width + padding.left + padding.right;
clientTop = border.Top;
clientLeft = border.Left;

2.外尺寸
offsetHeight = content.height + padding.top + 
padding.bottom + border.top + border.bottom;

offsetWidth = content.width + padding.left + 
padding.right + border.left + border.right;

offsetTop:该元素的上边框的边缘到offsetParent元素的上边框的内边缘的距离.
offsetLeft:该元素的左边框的边缘到offsetParent元素的左边框的内边缘的距离.
offsetParent:离计算元素最近的已经定位了的父级元素的
距离padding.top + padding.bottom

3.滚动尺寸
scrollHeight:滚动区域的高度,如果元素无法滚动,且其内部无超出该元素高度的元素,
则scrollHeight与clientHeight相等
scrollWidth:滚动区域的宽度,如果元素无法滚动,且其内部无超出该元素宽度的元素,
则scrollWidth与clientWidth相等

scrollTop:某一时刻垂直方向的滚动距离
scrollLeft:某一时刻水平方向的滚动距离
当元素被滚动时会触发的时机.onscroll
去看滚动条在谁的上面就给谁设置滚动时机.
<p>js瀑布流</p>
<p>收件箱</p>
<p>浏览器嗅探</p>
window.navigator.userAgent:
获取当前html文件运行在浏览器中的浏览器名称以及版本,
我们可以通过"Chrome/Safari/Firefox/IE/Opera"这些关键词
来判断当前用户打开的是哪一种浏览器,进而进行对应的兼容性操作.
indexOf():作用 查询是否有对应的字符串,如果有返回对应字符串的位置,
没有,返回-1
var browser = window.navigator.userAgent;
if(browser.indexOf("OPR") != -1){
	console.log('是欧鹏浏览器');
}else if( browser.indexOf("Chrome") != -1){
	console.log('是谷歌浏览器');
}else if(browser.indexOf("Safari") != -1){
	console.log('是Safari浏览器');
}else if(browser.indexOf("Firefox")){
	console.log("是火狐浏览器");
}else if(browser.indexOf("Trident")){
	console.log("是IE浏览器");
}
<p>js第11天</p>
<p>锅打灰太狼</p>
<p>寻找房租名find</p>
<p>js第12天</p>
<p>面向对象</p>
oop(object oriented programming)面向对象编程
面向对象以事物为中心,完成某件事件都需要哪些事物来参与,
参与该事件的事物都有哪些功能(特征和行为),完成该事件需要这些事物
相互协同共同完成,并且完成该事件只是所有事物功能中其中的一个小功能.

面向对象具有良好的可扩展性和重用性
面向对象可以降低我们代码的耦合性,提高代码的可移植性
面向对象接近于日常生活和自然的思考方式,可以提高我们软件开发的效率和质量.

面向对象编程的核心是转变考虑问题的方式.当我们看到一个问题的时候,我们需要
考虑完成该事件都需要哪些对象(事物)参与,每一种都由哪些特征和行为.
完成相应的事件需要不同的事物根据自身的行为,协调完成该事件

面向过程编程与面向对象(OOP)编程的区别:
面向过程:以事件为中心,将完成整个事件的操作分成若干个步骤,按照步骤来执行书写
代码.

面向对象:以事物为中心,完成某个事件需要哪些事物参与,每个事物都有什么特征(属性)
与行为(方法).此时,完成事件只是事物功能里的一小部分.

面向过程代表语言:c语言
面向对象代表语言:OC,JAVA,C++等

注意:除了js以外的面向对象语言都有完整的类和对象的概念,但是js(ECMAScript)中
并不存在类的概念,所有的元素都是对象.

类:具有相同特征和行为的事物(对象)的抽象.
对象是类的实例,万事万物皆对象
类是对象的类型.
区分对象的黄金法则:当我们看到某个概念的时候
如果每个人的大脑中想到的都是同一个事物的时候,此时就是对象;
反之则是类.

js中创建对象的方式有两种:
1.字面量创建对象
2.构造函数创建对象
字面量创建对象:使用字面量创建对象时,对象内包含两部分:属性和方法.
多个属性或者方法之间用逗号隔开;每一个属性或者方法都有名和值两部分组成,
两者用冒号链接.等价于"=",统称为键和值
1.
对象的属性和方法写在大括号内;
对象的属性:描述对象的特征.
对象的方法:描述对象的行为
//如果多个键值对的键相同,识别最后一个.

如何使用创建好的对象.
语法:
对象名.属性名 或者 对象名.方法名()
2.
构造函数创建对象
构造函数的函数名首字母需要大写.
this关键字在构造函数里,代指系统帮我们创建的对象自己.

调用构造函数创建对象
语法:
new 构造函数名(实参1,实参2);

new关键字的作用:
1.创建了一个空对象
2.让这个空对象去调用对应的构造函数,将要赋的值赋上.
3.将赋值好的空对象返回.

prototype:每一个函数对象(构造函数)都有一个prototype属性,
该属性中存储的是一个原型对象,为原型对象添加的属性或者方法都
可以被之后创建的任何一个实例对象所访问.可以帮助我么节省内存,
但是需要注意为原型对象添加的属性或者方法有一个特点就是所有实例
对象对应的属性或方法是需要完全相同的

constructor:是原型对象的属性,其存储的是创建对应实例对象时所使用的构造函数

<p>打印出一个对象的所有的属性值,(通用的代码)</p>

获取一个对象所有的属性名(keys)
1.Object.keys(对象名);
2.Object.getOwnPropertyNames(对象名);

var keys  = Object.keys(dog);
for(var i = 0;i < keys.length;i++){
	
//	var k = keys[i];
//	var v = dog[k];
//	console.log(v);
	
	console.log(dog[keys[i]]);
}

<p>快速枚举:枚举到的是对象的键</p>
语法:
  for(变量 in 对象){
  	
  }

function printAttrValueOfObj(obj){
//	var keys  = Object.keys(obj);
	for(var keys in obj){
			document.write(keys+':'+obj[keys]+'<br />');
	}
}

printAttrValueOfObj(dog);

<p>练习题(代码通用)</p>
定义三个女朋友,分别有姓别,年龄,身高
分别输出年龄最小者与身高最高者的个人信息
<p>js第13天</p>
<p>BOM:浏览器对象模型</p>
BOM:Browser Object Model
			
BOM:由一系列的对象组成,每个对象都有自己的属性和方法
用来管理浏览器窗口与窗口之间的通讯.

window是BOM中的顶层(核心)对象,所有的对象都是通过它延伸出来的.
由window延伸出来的子对象
1.document
2.history
3.location
4.navigator
5.screen
6.frames

window 窗口对象
window的特点:
1.所有的全局变量都是window的属性.
2.在使用window的子对象时可以省略window
3.this
	a.this在元素的关联事件的触发函数里面,代指的是该元素.
	b.this在哪个对象的方法里代指哪个对象
	c.在其他位置,this指向window
4.self 在任何地方都指向window

window的方法:
1.写法:window.open(URL,name,features);
	a.URL:要打开的网页地址
	b.name:窗口的名字,可以配合a链接的target实现在新打开的窗口打开的新网址,
	如果name相同只会打开一个网页.
	c.features:网页的一些特征
	注意:当创建一个新的窗口时,我们现在如果给新窗口一个网络地址
	因为域保护的问题,会报错.但是以后再工作过程中我们所有的网页
	都是放置在同一个服务器下,不会出现域名不同的情况.
	如何解决报错:1.不写新窗口的地址,2.写地址,但是保证与当前的网页域名相同
2.window.close() 关闭一个窗口
3.移动窗口
	a.moveTo(x,y);移动到某个位置,相对于整个窗口
	b.moveBy(x,y);移动到某个位置,相对于当前自己所在的位置
	x&gt;0 右移 x&lt;0 左移
	y&gt;0 下移 y&lt;0 上移
	
4.修改窗口的大小
	a.resizeTo(width,height);将对应的窗口设置成width,height,
	不能超过屏幕大小
	b.resizeBy(width,height);将对应的窗口设置成加上width,
	height之后的尺寸
5.设置窗口的滚动
	a.scrollTo(x,y)  设置对应窗口的滚动条的位置,
		x水平滚动条的位置,y竖直滚动条的位置
	b.scrollBy(x,y)	设置对应窗口的滚动条的位置,
		x水平方向上的滚动条在当前基础上加x之后的位置,
		y竖直方向上的滚动条在当前基础上加y之后的位置,
6.焦点
	a.获取焦点:focus
	b.失去焦点:blur
7.弹出框
	a.alert(message);
8.confirm(question);
9.prompt(question,answer);

//history历史记录,用于控制历史记录
history.length 在同一个窗口连续跳转的次数.
history.forward()	前进一页
history.back()	后退一页
//location;窗口的URL
//navigator,用于检测浏览器和操作系统的信息.
//screen 获取当前显示器的信息
width height 指的是显示器的宽和高
availWidth,availHeight指的是浏览器可用最大宽和高

//location
console.log(location);
console.log("协议:"+location.protocol);
console.log("主机:"+location.host);
console.log("主机名:"+location.hostname);
console.log("端口名:"+location.port);
console.log("文件目录:"+location.pathname);
console.log("参数列表:"+location.search);
//解决toString
console.log(history.toString());

console.log(navigator);
console.log("浏览代码"+navigator.appCodeName);
console.log("浏览器名"+navigator.appName);
console.log("浏览器版本"+navigator.appVersion);
console.log("是否开启cookie:"+navigator.cookieEnabled);
console.log("是否开启java:"+navigator.javaEnabled());
console.log("浏览器所在的计算机平台:"+navigator.platform);
//浏览器安装的插件
console.log(navigator.plugins);
//用户的代理信息,包括硬件平台,系统软件,应用软件,用户个人偏好设置
console.log(navigator.userAgent);


console.log(screen);
//width height 指的是显示器的宽和高
//availWidth,availHeight指的是浏览器可用最大宽和高


//1个像素点所能呈现的颜色的二进制数的最大位数,位数越大,组成的图片的大小就越大
console.log(screen.colorDepth);
console.log(screen.pixelDepth);

console.log(frames);
<p>js第14天</p>
<p>js事件</p>
js是一个以事件为驱动的脚本语言
在开发过程中想要实现页面内容与用户的交互,需要借助各种事件来完成.

系统会为每一个事件自动创建一个对象event,事件对象里存储了所有用户交互的
信息,我们可以在用户进行交互之后通过event对象获取到对象里的数据,进而进行
随后的反应操作.
/*/火狐浏览器不支持event对象,如果想用火狐,需要在对应的点击
事件的函数的参数部分人为的添加一个参数,这个参数就是对应的事件对象.
事件的分类
鼠标事件,键盘事件,表单事件,触屏事件
<p>鼠标事件</p>
鼠标单击事件onclick
鼠标双击事件ondblclick
鼠标移动到或移出某个标签
onmouseenter,onmouseleave
onmouseover,onmouseout
//onmouseenter不存在事件冒泡
//onmouseleave不存在事件冒泡
鼠标按下事件onmousedown
鼠标弹起事件onmouseup
鼠标右键点击oncontextmenu
鼠标滚轮事件onmousewheel
鼠标移动事件onmousemove
<p>键盘事件</p>
键被按下事件onkeydown
键弹起事件onkeyup
键一直按下的时候执行onkeypress
<p>表单事件</p>
表单事件:仅仅适用于表单操作以及表单类型的控件
1.onfocus:当某个表单控件处于被选中状态时执行,(获得焦点)
2.onblur:当某个表单控件取消被选中状态时执行,(失去焦点)
3.onsubmit事件是给form表单关联的
准备提交表单事件(点击submit按钮时执行)
4.onreset事件是给form表单关联的
表单被重置事件(点击reset按钮执行)
5.onchange事件是给指定的输入框关联的		
当指定的输入框中的内容发生变化时执行事件


读写性:控制某个对象或者某个属性的操作状态
读写: 指可以获取对应的值,也可以修改对应的值
只读:只可获取对应的值,不可以修改对应的值
<p>js事件对象的属性,鼠标的位置</p>
clientX||clientY 鼠标点击的点=>距离窗口上部和左边的距离.
screenX||screenY 鼠标点击的点=>距离屏幕上部和左边的距离.
<p>事件冒泡与事件捕获</p>
事件传播
1.冒泡
2.捕获
默认情况下,事件使用的是冒泡方式,我们也可以显示的指定事件的传播的方式.
方法时在注册事件监听里将useCapture参数的值设置成true

1.事件冒泡:
当某一个事件在某个dom元素被触发时,
事件将跟随该节点所继承自的各个父节点冒泡穿过整个dom节点层,一直到达根节点.
2.该事件的处理从Dom的跟节点开始处理,而不是从触发了该元素的dom元素开始.
依次通过触发节点的继承父节点,直至到达触发的最终元素停止.
<p>阻止事件传播</p>
1.阻止普通事件传播 event.preventDefault();
2.阻止冒泡事件传播 event.stopPropagation();
addEventlistener("type",listener,useCapture);
type:事件类型
listener:event listener function
useCapture:false代表冒泡,true代表捕获.
<p>js第15天</p>
<p>判断滚轮方向</p>
在火狐浏览器中对于滚轮事件的添加使用DOMMouseScroll,同时判断滚轮是向上还是向下,
也不在使用wheelDelta属性,而是使用detail属性,
同时detail属性对判别标准与普通的判别标准正好相反.大于零向下,小于零向上.
<p>自定义滚动条</p>
<p>碰撞检测</p>
<p>放大镜</p>
<p>js第16天,flappyBird</p>
<p>js第17天</p>
<p>cookie介绍</p>
cookie出现的原因:HTTP无状态协议,一旦数据传输完成(打开网页),
客户端与服务器端的链接立刻断开.如果需要再次通讯,需要重新连接.

cookie的使用原理:Cookie是一段文本信息,当客户端请求服务器,
如果服务器需要记录用户的状态信息,就可以为服务端发送一个cookie.
服务端就会把cookie存储起来,当再次请求时,服务端检查cookie以
确认客户端的信息.

cookie的使用场景:
1.保存用户的登录状态(自动登录)
2.跟踪用户行为(记录信息)
3.网站定制
4.购物车(浏览过的商品)

cookie的弊端:
1.容量小   4k
2.条数限制,最多20条
3.cookie可以被删除
4.cookie的安全性
5.cookie是有存储期限的
<p>cookie的使用</p>
获取当前域名下的cookie
同一个网站的多个页面共用一个cookie

添加一条cookie
cookie添加的格式
以键值对的形式:key=value;
eg:document.cookie = "name = ime";
如果key之前没有出现过相当于添加
如果key之前出现过相当于修改value

多条cookie之间用分号隔开
如果没有设置cookie的期限,那么完全退出浏览器之
后,cookie会被删除;真正保存cookie,需要设置期限.

方式1:设置cookie的失效日期,默认是当前时刻.
var expireDate = new Date();
expireDate.setDate(expireDate.getDate() + 1);
document.cookie="name=iwen;expireDate="+expireDate.toString();

方法2:设置存活的秒数
document.cookie = "gender=man;max-age=60";
document.cookie = "name=iwen";
如果同时设置了expires和max-age会怎么样?
答:会以max-age为准

删除一条cookie
设置时间期限让对应的键值对失效
max-age默认是当前时刻,值是-1
eg:document.cookie = "name=;max-age=-1"

五个重要的练习函数
1.判断是否有对应name的cookie
2.取出key对应的value
3.写一个添加cookie的函数
4.写一个删除cookie函数
5.写一个清除所有cookie函数
<p>localStorage对象</p>
localStorage:本地存储,HTML5的新技术
1.没有时间限制
2.提供了相关的操作函数(增删改查)

localStorage的length属性:存储数据的条数
eg:添加,修改,查找
localStorage.name = "王二麻子";
console.log(localStorage.name);
localStorage["age"] = 20;
// 语法:localStorage.setItem(key,value);
localStorage.setItem('gender',"男");
console.log(localStorage.getItem("gender"));

eg:删除
删除某一个
localStorage.removeItem("name");
删除全部
localStorage.clear();
遍历所有的localStorage属性
for (var i = 0; i < localStorage.length; i++) {
	var k = localStorage.key(i);
	console.log(k,localStorage.getItem(k));
}
<p>模拟记住用户名和密码</p>
记住用户名和密码的流程
1.点击登录,判断用户是否勾选记住用户名和密码框,
如果勾选,将用户名和密码存入cookie
2.再次打开网页时,判断cookie里是否有用户名和密码,
如果有,取出并显示在对应的文本框中
<p>js第18天</p>
<p>移动端基础</p>
手机端最常用的事件
1.touchstart:开始触摸
2.touchmove:移动
3.touchcancle:触摸取消
4.touchend:触摸结束
当触摸被取消,标准里并没有明确说明它的触发时机,
但是我们可以这么认为,当我们正在运行程序时,
有电话打进,本地闹钟等时机,系统会丢弃该触摸事件,
同时系统会自动对当前数据进行保存,或者游戏正在运行时,将游戏暂停.


如何绑定一个事件
答:移动端一般使用这种添加事件的方式.
eg:document.addEventListener("touchstart",touchStart,false);
<p>常用触摸事件的属性</p>
1.touches
屏幕上有多少个触摸点的集合
2.targetTouches
事件源对象上的触摸点个数,当前被触摸的对象上的触摸点个数的集合
3.changedTouches
距离最近一次触摸变化的点的集合
//测试方式一般采用往元素上输出东西的模式
document.body.innerHTML +="touches"+even.touches.length;
<p>移动端常用的属性</p>
1.clientX/clientY
距离浏览器可用范围的距离
2.screenX/screenY
距离屏幕左上角的距离
3.pageX/pageY
基于当前页面左上角的距离
<p>检测屏幕旋转</p>
监测屏幕的旋转需要onorientationchange
window.onorientationchange = function(){
	//alert(window.orientation);
	switch(window.orientation){
		case 0:{
			alert("竖直方向");
			break;
		}
		case 90:{
			alert("左横屏");
			break;
		}
		case -90:{
			alert("右横屏");
			break;
		}
	}
}
<p>元素拖拽</p>
var div1 = document.getElementById("div1");
//声明两个对象,分别存储之前与之后的两个点的坐标
var startPoint = {x:0,y:0};
var endPoint = {x:0,y:0};
div1.addEventListener("touchstart",function(e){
	var even = e || event;
	//记录开始点的坐标
	var obj = even.touches[0];
	startPoint.x = obj.pageX;
	startPoint.y = obj.pageY;
},false);

div1.addEventListener("touchmove",function(e){
	var even = e || event;
	var obj = even.touches[0];
	endPoint.x = obj.pageX;
	endPoint.y = obj.pageY;
	
	//计算增量
	var x = endPoint.x - startPoint.x;
	var y = endPoint.y - startPoint.y;
	div1.style.left = div1.offsetLeft + x + "px";
	div1.style.top = div1.offsetTop = y + "px";
	//重置起点
	startPoint.x = endPoint.x;
	startPoint.y = endPoint.y;
	//去掉浏览器自己的滚动
	even.preventDefault();
},false);
<p>摇一摇</p>
必须结合硬件的特性
ondevicemotion:得到重力加速度
var startPoint = {x:0,y:0,z:0};
var endPoint = {x:0,y:0,z:0};
//设置一个临界值,当某一方向上的加速度大于临界值时,
//我们才认为用户在摇动手机
var max = 30;
window.ondevicemotion = function(e){
	var even = e || event;
	var acceleration = even.accelerationIncludingGravity;
	startPoint.x = acceleration.x;
	startPoint.y = acceleration.y;
	startPoint.z = acceleration.z;
	//先判断
	if(Math.abs(endPoint.x - startPoint.x>max||
	Math.abs(endPoint.y - startPoint.y>max||
	Math.abs(endPoint.z - startPoint.z>max)){
		alert("摇一摇");
		break;
	}
	//在重置开始点的加速度
	endPoint.x = startPoint.x;
	endPoint.y = startPoint.y;
	endPoint.z = startPoint.z;
}
<p>swiperJS swiperjs swiper.js</p>
</pre>
<a href="http://www.swiper.com.cn/api/Progress/2015/0308/191.html">swiper配置选项1</a><br><br>
<a href="http://2.swiper.com.cn/api/freemode/2014/1217/44.html">swiper配置选项2</a>
<pre>
1.swiperJS常用于移动端网站的内容触摸滑动
swipeJS是用纯js打造的滑动特效控件.面向手机,平板等移动端
swiperJS开源稳定免费
2.使用场景:
	a.在移动端做程序架构
	b.做轮播图,非常简单  
3.使用方法:
 a.创建一个swiperJs对象
 	参数1:我们写的最外层的容器元素
 	参数2:对象,轮播图的各种属性
var mySwiper = new Swiper(".swiper-container",{
	 direction:"horizontal",
	 loop:true,
	 pagination:".swiper-pagination",
	 nextButton:".swiper-button-next",
	 prevButton:".swiper-button-prev",
	 autoplay:1000,
	 scrollbar:".swiper-scrollbar",
//切换控制效果effect(cube,fade,overflow,flip);
	 effect:'fade'	 
});
<p>touchjs touchJS touch.js</p>
</pre>
<a href="http://cloudajs.org/docs/step4_API_Documentation#h2_7">clouda团队官网==>touchjsApi</a>
<pre>
Touchjs的基本概念:
1.是什么?
Touchjs是移动设备上的手势和事件库,由百度云Clouda团队维护,
也是百度内部使用的开发工具
TouchJS的源码已经托管到github
TouchJs只能在webkit内核下的浏览器使用
2.如何使用touchJS
	a.下载touchjs源码并引入工程里 
	b.绑定事件:touch.on(element,type,callback);
	element:要绑定事件的元素
	type:绑定的事件类型,可以接受多种类型,
	多个类型之间用空格隔开,支持原生事件的透传.
	(pinch,rotate,swipe,drag,hold,tap,doubletap)
	callback:事件处理的函数
<p>正则表达式</p>
</pre>

<a href="http://www.jb51.net/tools/zhengze.html#grouping">参考文章:30分钟入门正则</a>
<pre>
正则表达式
1.任何前端,后端,移动端,IOS,Android,java,
学好正则,可以对任意信息进行检测,匹配,提取,判断
2.是一门新的语法格式
3.你不会写,可以搜索
正则表达式:regular expression
在一个正则表达式中,描述了,匹配字符串的规则,
我们可以通过该规则,进行字符串的监测.
<p>正则表达式的基础知识</p>
正则表达式的基本知识
1.正则表达式中有两种字符
	a.普通字符,a-z,A-Z,[0-9],汉子,_
	b.元字符,具有特殊意义的字符.\d \s \w * + ? .
2.如何创建一个正则表达式对象.
	a. var reg = new RegExp(参数1,参数2);
		这两个参数都是字符串类型
		参数1:岁规定的规则
		参数2:设置的属性(attribute),三个参数值可选
		i:忽略大小写
		m:它配合占位符(^ $)使用
		g:全局匹配
	b.创建正则表达式对象的简单方法
		var 对象名 = /参数1/参数2
		参数不能是字符串
		参数1:匹配规则
		参数2:(i,m,g)
reg.test(str)
正则表达式对象的test()方法,该函数的作用:
用来验证字符串中有没有符合规则的子字符串,
有,返回true,没有返回false;
test(参数),参数是我们想要验证的字符串
<p>元字符</p>
元字符:

\n :换行符
\t:制表符
\r:回车符
*************

\d:代表数字 [0-9]
\D:代表非数字 [^0-9]
\s:空白符(空格,回车,制表符)
\S:非空白符
\w:字符(字母a-z,A-Z,0-9,_);
\W:非字符(对上面取反)
.:代表了除\n之外的字符
**************************

代表个数
*: 个数>=0
+: 个数>=1
?:个数{0或1},只能去0或1

重复次数
{n}  :个数为n的
{n,} :个数>=n
{n,m}  :m>=个数>=n
? === {0,1}
* ==={0,}
+ ==={1,}

**************************

连字符表达的字符范围
-连字符,结合[]一起使用,表达一个范围
[0-9]:所有的数字
[a-z]:所有的小写字母
[A-Z]:所有的大写字母
\u:Unicode编码
中文的范围:\u4E00-\u9fa5
伊可:\u4f0a\u53ef\u000d\u000a

[],匹配括号里出现的字符  eg:[0123456789] == \d
[^x],匹配除x以外的字符(包含空格)(匹配上返回true)
eg:[^0123456789] == \D
*************************************************
<p>字符串的match方法</p>
字符串的match方法,跟正则表达式对象有关
match(参数)
参数:正则表达式对象
返回值:如果一个字符串按照正则表达式对象的规则
可以匹配到内容,就把内容写进数组,并返回此数组
如果匹配不到,返回null(有特殊)
<p>字符串的replace</p>
字符串函数
replace(参数1,参数2);
参数1:正则表达式对象
参数2:要替换的内容
返回值:返回经过替换后的字符串
注意:返回值是被替换后的字符串,原字符串不被修改.
<p>字符串search方法</p>
字符串方法
search(参数)
参数:正则表达式对象
返回值:如果匹配到正则中的字符串,就返回对应的下标,
如果匹配不到返回-1
<p>lastindex</p>
每个正则对象都有一个lastindex属性,当进行全局匹配时(特别是在
使用for循环式),如果上一次匹配规则成立,那么正则对象会记录下
上一次匹配到的索引位置的下一个位置(下标)用到下一次匹配中去,
这么会造成下一次匹配时不是从字符串的开始位置开始匹配,
解决办法:每次匹配成功后,将正则对象的lastindex属性置为0
<p>正则表达式里的定位符</p>
^:用来表示字符串的开头
$:用来表示字符串的结尾
\b:用来表示字符串中单词的边界

//判断一个字符串只能是"abc"
var str = "hello abc world";
var reg = /^abc$/;
<p>m的作用</p>
m的作用:影响对行头和行尾的解释,影响^ $,
当不加时,^$指的就是整个字符串的头和尾
如果加了m.而且字符串中有换行,
那么^ $指的就是每一行的头和尾
<p>选择符和分组符</p>
选择符 字符串1|字符串2 
匹配字符串里的字符串1或者字符串2
分组符 ()
把同一分组的字符用()括起来
<p>jquery JQ Jquery</p>
</pre>
<a href="http://www.jquery123.com/">jQuery API 中文文档</a>
<pre>
jquery是对原生javascript的封装,语法更简洁,使用更方便.
jq 1.x 支持ie678
jq 2.x 不支持ie678

1.jq选择器
2.jq操作元素
3.jq动画

jq的使用:
1.引入在线的jq库
2.下载jq并引入本地的jq文件
<p>PHP基础,basic.php</p>
header("Content-type:text/html;charset=utf8");//声明字符编码

输出:
	print()函数输出一个或多个字符串
	print()函数实际上不是函数,所以不必使用字符串
	echo()函数输出一个或多个字符串
	print_r()函数输出数组
	var_dump()函数输出对应数据的具体信息,包括类型和具体的值
变量的声明:使用$关键字
php常量的定义:define(常量名,常量值);
define("PI",3.1415926);

运算符%:取余运算,
注意:做取余操作的两个数必须是整数,如果不是则将其转
换成整数做操作,向下取整;

单纯的加号,做的是加法运算,如果是字符串与数字的加号运算,
如果字符串开头有数字,会截取数字部分进行加法运算,
如果字符串中的数字不在开头或在其他位置,则把字符串转
换成零后,然后做加法运算.
其他运算符运算同js运算符

字符串表示
1."字符串",如果使用该方式,字符串中的变量系统会自动替换,
为了提高效率,我们需要在变量的起始和结束位置设置{},表示变量的范围
2.'字符串',如果使用该方式,字符串中的变量不会做替换,会作为字符输出
3.定界符
&lt;&lt;&lt;EOD :表示定界符的开始
EOD;代表定界符结束,注意:定界符结束的位置不能出现多余的空格
eg:
$info1 = &lt;&lt;&lt;EOD
	姓名:kk
	年龄:23
	爱好:code
	人生格言:在哪里跌倒,就在哪里躺着;
EOD;
$info2 =&lt;&lt;&lt;EOD
	姓名:kk;&lt;br&gt;
	年龄:23;&lt;br&gt;
	爱好:code;&lt;br&gt;
	人生格言:在哪里跌倒,就在哪里躺着;
EOD;
echo $info1,$info2;

//双层for循环中,外层控制行数,内层控制列数
for ($i = 0; $i < 3; $i++) { 
	for ($j = 0; $j < $i+1;$j++) { 
		echo "*html空格实体";
	}
	echo "&lt;br&gt;";
}
求两个数的最大公约数和最小公倍数

//普通方法

$num4 = 20;
	$num5 = 30;
	$min = $num4 < $num5? $num4:$num5;
	for ($i = $min; $i >= 1; $i--) {
		$gys = 1; 
		if ($num4%$i == 0 && $num5%$i == 0) {
			$gys = $i;
			break;
		}
	}
$gbs = $num4*$num5/$gys;
echo "最大公约数是{$gys}";
echo "最小公倍数是{$gbs}";

//辗转相除法

$num4 = 20;
$num5 = 30;
$min = $num4 < $num5? $num4:$num5;
$max = $num4 + $num5 - $min;
while ($max % $min != 0) {
	$temp = $min;
	$min = $max%$min;
	$max = $temp;
}
$gys = $min;
$gbs = $num4*$num5/$gys;
echo "最大公约数是{$gys}";
echo "最小公倍数是{$gbs}";
<p>PHP,String,array,fn,php字符串,php数组,php函数</p>
<p>字符串函数</p>
strpos(source,des);
查找source中指定的des的内容,如果存在会返回des首字母第一次出现的位置,
否则返回bool类型的数据false,注意查找过程区分大小写不区分大小写使用stripos();
字符串的替换str_replace(参数1,参数2,参数3);
参数1:需要替换的部分字符串
参数2:用来替换部分字符串的内容或者符号
参数3:需要替换的字符串对象
eg:
$infor = "共产党万岁,我爱共产党";
str_replace("共产", "**",$infor);

字符串的截取substr(参数1,参数2,参数3)
参数1:指代需要截取的字符串
参数2:指代开始截取的位置
参数3:指截取字符串截取的长度,
注意:如果参数3省略,则代表从开始截取的位置一直截取到字符串的结束
获取字符串的长度strlen($infor);
在字符串操作过程中,操作的字符串下标或长度都是以字符为
单位但是字符串中的中文并不占有一个字符,根据计算机设置的不同,
中文有可能占据2个以上的字符,在这里每一个中文占据3个字符.
utf-8字符集中:一个汉字占三个字节
gbk字符集中:一个汉字占二个字节

strstr(参数1,参数2):
从参数1中查找存在参数2指定的内容,如果存在返回从参数2首字母在
参数1中首次出现的位置到字符串后面所有的内容.但是此操作区分大小写
stristr($haystack, $needle),不区分大小写

strtoupper():将字符串转换成大写(针对英文字符串)
strtolower():将字符串转换成小写(针对英文字符串)
<p>数组</p>
PHP数组的分类
1.索引数组 2.关联数组 3.多维数组

1.索引数组:
	1.创建索引数组
		$arr1 = array(1,2,"aa","bb");
	2.索引数组中元素的访问
		数组名[下标] $arr1[1];
	3.判断索引和关联数组中是否含有某一个指定的元素,
		in_array(value,array,type);
		参数1:规定要在数组中搜索的值
		参数2:规定要搜索的数组
		参数3:如果设置该参数为true,则判断搜索的数据与
		数组的值的类型是否相同
2.关联数组:
	1.创建关联数组
	  $arr2 = array("name"=>"iwen","sex"=>"m","age"=>30);

	2.获取数组中的指定元素
	  $arr2["name"];

	3.为数组添加元素
	  $arr2["salary"] = 1000;

	4.unset():清除数组中的元素
	  unset($arr2["sex"]);

	5.修改数组中的元素
	  $arr2["salary"] = 500;

	foreach():遍历关联数组中的所有元素,
	foreach ($arr2 as $key => $value) {
		echo "{$key}=>{$value} &lt;br&gt;";
		}
<p>数组函数</p>
向数组的最后一个位置添加元素
$arr1[] = 'keke';
array_push($arr1,"hello world");

删除数组中的最后一个元素
array_pop($arr1);

向数组的第一个位置添加元素
array_unshift($arr1,"我是第一个元素");

删除数组中的第一个元素
array_shift($arr1);
可以实现数组中元素的替换,删除,插入
array_splice($arr1,0,1,"ime");//替换
array_splice($arr1,0,0,"code");//插入
array_splice($arr1,0,1);//删除

遍历索引数组,count()获取数组中元素的个数
$arrlength = count($arr1);
for($i = 0;$i < $arrlength;$i++){
	echo $arr1[$i];	
	echo "html空格实体";
}

快速创建数组
range(min,max,stepper)
规定索引数组的范围(min,max);
stepper步长(可选),默认为1;
<p>数组排序</p>
1.索引数组的排序
升序排序
	sort($arr3);
降序排序
	rsort($arr3,2);
2.关联数组的排序
按照关联数组的键进行升序排序
	ksort($arr4);
按照关联数组的键进行降序排序
	krsort($arr4);
按照关联数组的值进行升序排序
	asort($arr4);
按照关联数组的值进行降序排序
	arsort($arr4);
注意:
数组排序中,所有的排序方法都可以指定排序时所依据的方式
如果仅仅指定排序的数组,不指定依据的方式,会按照默认的自然排序进行排序
首先系统会将数组中的数据分类处理,然后对相同类别的数据进行排序,
后将排序的数据进行合并
<p>php函数</p>
定义在函数外面的变量叫全局变量
注意PHP中全局变量如果在函数内部使用需要用global修饰,否则无法使用

局部变量:定义在函数内部的变量称为局部变量
局部变量的作用域从函数定义开始到函数调用结束,
一旦函数调用结束,局部变量会自动被系统回收

静态变量:通过static修饰的变量.
静态变量的空间只会在程序第一次使用的时候初始化一次,
之后变量一直存在直到程序运行结束

函数命名的规范:
1.函数名由字母,数字,下划线组成,并且数字不能开头
 2.PHP函数名不区分大小写
3.PHP中不允许函数重载(函数名相同)
4.函数命名的时候不能使用系统的关键字或预留字段
5.见名知意

变量的变量,将{$变量名}中的值作为下一个变量的变量名
eg:
$txt = "word";
$$txt = 30;
echo $word;

函数的传值和传址过程:

传值操作:
  实际参数向形式参数传递数据的时候传递的只是变量中存储的数据,
  此时在函数内部对形式参数的值修改并不会影响外界的实际参数

传址操作:
  实际参数向形式参数传递数据的时候传递的是实际参数的地址,
  此时在函数内部对形式参数的修改,实际上系统会根据参数中的地址找到
  地址对应的实际参数,进而修改实际参数中的数据.从而实现函数内部修
  改函数外部变量的目的.

取地址符:&

函数的传址操作eg:

$num3 = "aaa";
function changeValue(&$number){
	 	$number = 20;
	 }
changeValue($num3);
echo $num3;
<p>文件操作</p>
文件的打开方式
r,r+,w,w+
r:文件打开之后只允许从文件中读取内容
r+:文件打开之后可以读或写内容,但是写入内容的时候注意该
种方式不会清除文件中的内容,是在原内容的基础上做替换
w:文件打开之后只允许写内容,而且每次打开文件系统都会自动清空文件内的原内容
w+:文件打开之后可以允许写或读内容,但是每次打开文件,系统会自动清
空文件的原内容,因此实际上不能正常读取文件内容.

注意:
r,r+在操作文件的时候如果文件呢不存在则无法操作文件.
w,w+则相反,它会自动创建该文件然后在对文件做操作.

文件打开的另一种操作:

a:打开文件之后,只能向文件中写入内容
a+:打开文件之后,可以完成文件的读写操作
注意:a,a+在写入内容时,是在文件原内容的基础上在后面添加新内容
并且如果操作的文件不存在也会自动创建该文件,然后执行对应的操作

向文件中写入内容:

步骤1:打开对应的文件,并返回对应的文件句柄,
文件句柄的作用是操作对应的文件
$handle = fopen("infor.txt","a+");

步骤2:向文件中写入内容
fwrite($handle,"keke\n");

步骤3:关闭文件
fclose($handle);

读取文件内容:

步骤1:打开对应的文件,并返回对应的文件句柄,
文件句柄的作用是操作对应的文件

步骤2:读取文件中的数据,返回文件中的内容
$info = fread($handle,filesize("infor.txt"));

步骤3:关闭文件
fclose($handle);


其他操作文件函数说明:

fgets($handle,length)函数:从文件指针中读取一行
注意:当获取过程中碰到\n(换行)的时候代表第一行读取结束
length:规定要读取的字节数,默认是1024字节(1k);

feof(file)函数:检测是否已到达文件末尾
file参数是一个文件指针.这个文件指针必须有效,并且必须指向一个
由fopen()或fsockopen()成功打开(但还没有被fclose()关闭)的文件
使用这两个函数的例子:

$handle = fopen("infor.txt","a+");
//输出文本中所有的行直到文件结束
while(!feof($handle)){
	echo fgets($handle)."<br>";
}
fclose($handle);


如果您想做的所有事情就是打开一个文件并读取其内容，那么readfile()函数很有用
readfile(filename)函数:输出一个文件
如读取成功则readfile()函数返回字节数,若失败返回false
可以通过@readfile()形式调用该函数,来隐藏错误信息
filename:规定要读取的内容


file_put_contents($filename,$data,$flags,$context);//向文件写入内容
该函数的功能与依次调用fopen(),fweite()以及fclose()功能一样
提示:FILE_APPEND可避免删除文件中已有的内容
注释:本函数可安全用于二进制对象
参数说明:
$filename:必须,规定要写入的数据文件,如果文件不存在,则创建一个新文件
$data:可选,规定要写入文件的数据,可以是字符串,数组或数据流
$flag:可选,规定如何打开/写入文件.
可能的值:FILE_USE_INCLUDE_PATH,FILE_APPEND,LOCK_EX
$context:可选,规定文件句柄的环境
$context是一套可以修改流行为的选项,若使用null,则忽略
返回值:写入到文件内数据的字节数
file_get_contents("infor.txt",false,null,3,10);//从文件中读取内容
<p>文件操作2</p>
form表单的作用:
通过表单控件提供给用户数据输入的方式,同时通过对应的网址链接
将用户输入的数据提交给对应的服务器,保证服务器对数据做对应的处理

$_GET,$_POST:超全局变量用来获取通过get方式（post方式）提交给服务器的数据

</pre><span>get和post两种提交数据的方式的区别:</span><pre>

get:提交的数据量比较小，最大为288个字节，但是数据提交的效率高。
同时由于get中数据和网址被拼接在一起同时传输，因此数据的传输不够安全。

post:提交数据的量比较大，默认为2M，但是数据传输效率比较低。
同时因为post传输数据的时候数据传输和网址链接分开进行，因此数据的安全性比较高。
注意:
get:经常应用于客户端向服务器请求数据。post经常应用于客户端向服务器传递数据。
<p>文件夹,文件创建,删除,复制,获取,重命名</p>
创建文件夹
$path = "./doc";
//判断当前路径下是否存在对应的文件夹
file_exists($filename):判断指定的路径下是否存在对应的文件或文件夹
if(!file_exists($path)){
	mkdir($path);//在指定的路径下创建文件夹(makedir)
	chmod($path,0777);//将文件夹的权限修改成读写权限,默认是0755:只读权限	
}

文件的拷贝
$sourcePath = "./infor.txt";
$desPath = "./doc/infor1.txt";
$res = copy($sourcePath, $desPath);

文件的重命名
$res = rename("./infor3.txt", "./infor2.txt");

删除指定的文件
$res = unlink("./infor2.txt");
if($res){
	echo "文件delete成功";
}

获取指定路径下的文件夹中的所有的文件
$path = ".";

打开文件夹目录句柄
$handle = opendir($path);
while ($file = readdir($handle)) {
	echo $file."html实体线";
}

关闭文件夹的目录句柄
closedir($handle);

获取指定路径下的所有文件或文件夹
$files = scandir($path);
print_r($files);

删除指定路径下的空文件夹(只能用来删除空文件夹);
rmdir($path."/doc");
<p>PHP正则表达式</p>
preg_match_all()和preg_match()的区别:
preg_match():匹配一次,返回值代表当前有多少个匹配的字符,
只是此处只返回0或1;
preg_match_all():功能和上面相同只是匹配可以匹配可以匹配多次

preg_replace():按照正则表达式完成字符串的替换
preg_split():按照正则表达式完成字符串的分割,最终返回分割之后的数组
preg_grep():按照正则表达式完成数组元素的匹配,将匹配到的数据以一个新的数组形式返回

字符串的替换:

$content = "afsdlafsdiusghg";
$res = preg_replace("/a/","A",$content);
echo $res;

字符串的分割:

$content = "my name is kkcode";
$res = preg_split("/\s/",$content);
print_r($res);

匹配数组元素:

$input = array(1,2,"aaa","bbb");
$res = preg_grep("/\D/",$input);
print_r($res);
<p>nodejs,nodeJS</p>
</pre>
<a href="http://blog.csdn.net/my_study_everyday/article/details/52819301">01-info&nbsp;&nbsp;(nodejs介绍)</a>
<a href="http://blog.csdn.net/my_study_everyday/article/details/52819321">02-http&nbsp;&nbsp;(http模块)</a>
<br><br>
<a href="http://blog.csdn.net/my_study_everyday/article/details/52841097">03-module&nbsp;&nbsp;(模块介绍,使用)</a>
<a href="http://blog.csdn.net/my_study_everyday/article/details/52841311">04-package&nbsp;&nbsp;(包的介绍,使用)</a>
<br><br>
<a href="http://blog.csdn.net/my_study_everyday/article/details/52842490">05-path&nbsp;&nbsp;(path模块)</a>
<a href="http://blog.csdn.net/my_study_everyday/article/details/52842490">06-url&nbsp;&nbsp;(URL模块)</a>
<br><br>
<a href="http://blog.csdn.net/my_study_everyday/article/details/52842490">07-util&nbsp;&nbsp;(util模块)</a>
<pre>
<p>nodejs介绍</p>

 全栈工程师:又叫双端工程师,即会前端又会后端的工程师
 nodejs官网:https://nodejs.org/en/
 在命令行中,可以使用node
 常用命令:
 1.node -v,查看电脑安装的node版本
 2.node,进入node的环境,可以执行你写的js代码
 3.在node环境下,使用ctrl+c 或者输入[.exit],退出node环境
 4.node *.js,执行某个js文件
 5.cd,进入到某个文件夹
 6.pwd,显示当前文件夹的路径
 7.ls,显示当前文件夹内的文件

/**
 * node.js:称node或nodejs
 * 可以运行在服务器端的的js平台
 * 前端的js后服务器端的js区别:
 * 1.前端的js,浏览器就是解析器;
 * 服务器端的js,node.js是平台,是解析器
 * 2.前端的js,主要的功能DOM操作;
 * 服务器端的js,主要功能是搭建服务器,提供数据
 * 3.服务器端的js,去掉了与DOM操作的相关的内容,没有兼容性问题
 */
// webstorm工具支持运行js,快捷键 ctl + shift + r
// 退出webstrom工具运行js的平台快捷键 shift+esc
</pre>
<pre>
	<p>写在最后的话</p>
1.不要重复

	这是一条非常值得遵循的伟大原则。我很习惯于回过头去检查自己写下的代码，
	重构那些被多次使用的部分。虽然在将一个长方法分解为若干个短方法时，会遇
	到一些困难。Ctrl + R + M在visual Studio中非常有用，可以帮助你重构
	代码为单独的方法。这使得代码更加可重用和可测试。

2.命名变量的时候,要说明它们是什么，而非它们是什么样的数据类型

	唯一的例外是，如果你正在处理别人的代码，并且需要继续参与的，
	那么你应该遵照他们的命名规则。

3.给你的方法取一个明确说明他们要做什么的名称

	这一条如果做得好，那么将大大减少注释的必要。如果你的代码清
	晰易读，那还需要注释干什么。

4.不要使用奇奇怪怪的数字和字符串常量

你的代码中不应该有任何会造成他人误解或需要猜测的数字和字符串值。创建
常量、枚举和私有变量时，要给他们取一个能够更易于理解的名字。

5.可能的话，自己写方法，

	这样在测试方法时，就不会对应用程序的其他部分有任何依赖
	将方法写成不需要关注从哪里调用的方式。这样会让代码更可测和更可重用。
	如果你正在使用会话值或app设定值，那么把它们作为变量传递，得到会话，
	并在你调用方法的时候配置值。这能让代码变得更可测。

6.不要害怕寻求帮助

	这句话不是让你在碰到所有问题时都去寻求帮助，我的意思首先你得自己去思考，
	去尝试自己解决问题，但如果你实在想不出解决方法，那么就应该去寻求他人的帮助。
	可能已经有人经历过这个问题，知道如何解决它。同时，在告诉别人你正在做什么，
	你期待什么样的结果，问题是什么的过程中，或许灵机一现，
	搞不好你自己就揪出问题的关键了呢。

7.不拖延

	如果你看到bug或乱码，那么当时就解决然后再前进。
	不要想着以后去做或让别人去做。

8.与他人分享知识

	不要敝帚自珍。尝试创建一种互助的文化。你会发现，团队的工作效率比
	单枪匹马更高，并且互相帮助的氛围能更快地提升各自的水平。同事的进步，
	并不会让你落后，也不会让你有被炒的风险。相反，你变得更有价值，
	因为你不但拥有渊博的知识，敢于学习，还能帮助周围的人一起提高。

9.当你的同事沉浸在思考中时，不要打断他们

	己所不欲，勿施于人，当你自己沉浸在编程中时，当你的大脑高速运转工作时，
	就像你正在小心翼翼地用纸牌搭建房子一样，你也不希望有人来打搅你。这时如
	果有人问你问题的话，那么你的注意力必然无法集中，就像房子可能会很容易坍
	塌。这可能需要5到10分钟的时间才能将注意力重新集中起来，将思绪一一理顺，
	而原本这个问题只需要Google搜索一下，或者询问别人就能解决。如果你在这方
	面尊重你的同事，并且让他们知道这样做的重要性，那么他们也会做相同的事，
	从而反过来让你变得更高效。

10.积极地面对批评，而不是消极抵制。

	对我来说，批评是一个让我能够改善提高的机会。如果还有一种做事的
	方法是我没有想到的，那么我会想去了解它，因为这或许能帮助我改进自己。
</pre>
<p>一些前端网站</p>
<a href="http://www.w3cfuns.com/house">我的blog</a>
<a href="http://my.csdn.net/my/mycsdn">我的CSDN</a>
<a href="http://www.bootcss.com/">bootstrap中文网</a>
<a href="http://gold.xitu.io/">掘金</a>
<a href="http://www.w3cplus.com/source/front-end-developer-excellent-tool.html">前端工具</a>
<a href="http://www.cnblogs.com/">博客园</a>
<p>平常阅读</p>
<a href="https://github.com/dwqs/blog/issues/32">九个Console命令</a>
<a href="http://www.cnblogs.com/wangfupeng1988/p/4001284.html">深入理解javascript原型和闭包系列</a>
<a href="http://blog.csdn.net/dracotianlong/article/details/7761104">
	JS 字符串操作函数
</a>
<a href="http://www.cnblogs.com/slowsoul/default.html?page=2">JavaScript设计模式：单体模式</a>
<a href="http://zccst.iteye.com/category/144638">封装</a>
<a href="http://blog.csdn.net/liangklfang/article/category/6007733">
	高山上的鱼blog
</a>
<a href="https://segmentfault.com/q/1010000004351238">如何封装常用的JS方法?</a>
<a href="http://www.cnblogs.com/leejersey/p/3545372.html">专注WEB前端开发
爱设计，爱编程，</a>
<a href="http://javasam.iteye.com/blog/1929042">js常用方法或对象封装------待续中。。。。</a>
<a href="http://www.tuicool.com/articles/yMnma2">自己动手封装js工具类（JS中定义类的几种方式）</a>
<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html">阮一峰的网络日志=>封装</a>
</div>
</div>
<script>
var links = document.getElementsByTagName("a");
for (var i = 0; i < links.length; i++) {
	links[i].target = "_black";
	links[i].style.display = "inline-block";
	links[i].style.lineHeight = "30px";
	links[i].style.width = links[i].offsetWidth + 50 + "px";
}
</script>
</body>
</html>
